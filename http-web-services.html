<!DOCTYPE html>
<html><head>
  
  <meta charset="utf-8">
  <title>HTTP Web Services - Dive Into Python 3</title>

  
<!--[if IE]><script src=j/html5.js></script><![endif]-->
  
  <link rel="stylesheet" href="dip3.css">

  
  <style>
body{counter-reset:h1 14}
mark{display:inline}
  </style>
  
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="mobile.css">

  
  <link rel="stylesheet" media="print" href="print.css">

  
  <meta name="viewport" content="initial-scale=1.0">

</head><body>
<form action="http://www.google.com/cse">
  <div><input name="cx" value="014021643941856155761:l5eihuescdw" type="hidden"><input name="ie" value="UTF-8" type="hidden">&nbsp;<input name="q" size="25" placeholder="powered by Google™" type="search">&nbsp;<input name="root" value="Search" type="submit"></div>
</form>

<p>Vous êtes ici&nbsp;: <a href="index.html">Accueil</a> <span class="u">‣</span> <a href="table-of-contents.html#http-web-services">Plongez
au cœur de Python 3</a> <span class="u">‣</span>
</p>

<p id="level">Niveau de difficulté: <span class="u" title="advanced">♦♦♦♦♢</span>
</p>

<h1>Services Web HTTP</h1>

<blockquote class="q">
  <p><span class="u">❝</span> A ruffled mind makes a restless pillow. <span class="u">❞</span><br>
— Charlotte Brontë
  </p>
</blockquote>

<p id="toc">&nbsp;
</p>

<h2 id="divingin">Lançons Nous</h2>

<p class="f">Philosophiquement, je peux décrire les services web <abbr>HTTP
</abbr> en 15 mots&nbsp;: échanger des données avec des serveurs
distants en
n'utilisant rien d'autre que des opérations <abbr>HTTP</abbr>. Si vous
voulez
obtenir des données d'un serveur, utilisez <abbr>HTTP</abbr> <code>GET</code>.
Si vous voulez envoyer des nouvelles données au serveur, utilisez <abbr>HTTP
</abbr> <code>POST</code>. Certaines <abbr>API</abbr> de services web
<abbr>HTTP
</abbr> plus avancées offrent de créer, modifier et supprimer des
données, en utilisant <abbr>HTTP</abbr> <code>PUT</code> et <abbr>HTTP</abbr>
<code>DELETE</code>. C'est tout. Pas de registres, pas d'enveloppes,
pas
d'emballages, pas de tunnels. Les «&nbsp;verbes&nbsp;» inclus dans
le protocole <abbr>HTTP</abbr> (<code>GET</code>, <code>POST</code>,
<code>PUT</code> et <code>DELETE</code>) correspondent directement aux
opérations de niveau application pour récupérer, créer, modifier et
supprimer des données.
</p>

<p>Le principal avantage de cette approche est la simplicité, et cette
simplicité s'est montrée populaire. Les données
&nbsp;—&nbsp; habituellement du <a href="xml.html"><abbr>XML</abbr></a>
ou
du <a href="serializing.html#json"><abbr>JSON</abbr></a>&nbsp;—&nbsp;
peuvent
être construites et stockées statiquement, ou
générées dynamiquement par un script côté
serveur, et tous les langages de programmation majeurs (y compris
Python bien
sur!) incluent une librairie <abbr>HTTP</abbr> pour les télécharger.
Le
debugging est aussi plus facile&nbsp;: chaque ressource dans un service
web <abbr>HTTP</abbr> possède une adresse unique (sous la forme d'une
<abbr>URL</abbr>). Vous pouvez la charger dans votre navigateur et voir
immédiatement les données brutes.
</p>

<p>Exemples de services web <abbr>HTTP</abbr>&nbsp;:
</p>

<ul>

  <li> <a href="http://code.google.com/apis/gdata/">Google Data <abbr>API</abbr>s</a>
permettent d'interagir avec une grande variété de services Google,
comme <a href="http://www.blogger.com/">Blogger</a> et <a href="http://www.youtube.com/">YouTube</a>,
  </li>
  <li> <a href="http://www.flickr.com/services/api/">Flickr Services</a>
permettent d'envoyer et de télécharger des photos de <a href="http://www.flickr.com/">Flickr</a>,
  </li>
  <li> <a href="http://apiwiki.twitter.com/">Twitter <abbr>API</abbr></a>
permet de mettre à jour le statut sur <a href="http://twitter.com/">Twitter</a>,
  </li>
  <li> <a href="http://www.programmableweb.com/apis/directory/1?sort=mashups">
…et bien plus</a>
  </li>
</ul>

<p>Python 3 offre deux librairies pour interagir avec les services web <abbr>
HTTP</abbr>&nbsp;:
</p>

<ul>

  <li> <a href="http://docs.python.org/3.1/library/http.client.html"><code>
http.client</code></a> est une librairie de bas niveau qui implémente
le <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html"><abbr>RFC</abbr>
2616</a>, soit le protocole <abbr>HTTP</abbr>,
  </li>
  <li> <a href="http://docs.python.org/3.1/library/urllib.request.html"><code>
urllib.request</code></a> est une couche d'abstraction batie sur <code>http.client</code>.
Elle fournit une <abbr>API</abbr> standard pour accéder aux serveurs <abbr>HTTP</abbr>
et <abbr>FTP</abbr>, suit automatiquement les redirections <abbr>HTTP</abbr>
et supporte les authentification <abbr>HTTP</abbr> communes.
  </li>
</ul>

<p>Alors laquelle devriez-vous utiliser ? Aucune des deux, mais plutôt
<a href="http://code.google.com/p/httplib2/"><code>httplib2</code></a>,
une
librairie tierce open source qui implémente plus complètement <abbr>HTTP</abbr>
que <code>http.client</code>, et offre une meilleure abstraction que <code>urllib.request</code>.
</p>

<p>Pour comprendre pourquoi <code>httplib2</code> est le bon choix,
vous devez d'abord comprendre <abbr>HTTP</abbr>.
</p>

<p class="a">⁂
</p>

<h2 id="http-features">Caractéristiques du HTTP</h2>

<p>Il y a cinq caractéristiques importantes que tous les clients
<abbr>HTTP</abbr> devraient supporter.
</p>

<h3 id="caching">La mise en cache</h3>

<p>Le plus important à comprendre est que, peu importe le type
de service web, l'accès au réseau est incroyablement coûteux.
Je ne parle pas d'euros et de cents (même si la bande passante n'est
pas
gratuite). Je veux dire qu'il faut un temps extraordinairement long
pour ouvrir une connexion, envoyer la requête et récupérer
la réponse du serveur distant. Même sur la connexion la plus rapide,
la <i>latence</i> (temps nécessaire pour envoyer la requête
et commencer à recevoir la réponse) peut tout de même
être plus grande que prévu. Un routeur qui se comporte mal, un
paquet perdu, un proxy intermédiaire attaqué&nbsp;—&nbsp;
il n'y a <a href="http://isc.sans.org/">jamais de moment ennuyeux</a>
sur
Internet, et vous ne pouvez vraisemblablement rien y faire.
<aside><code>Cache-Control: max-age</code> signifie «&nbsp;ne pas
déranger avant une semaine.&nbsp;»</aside>
</p>
<p><abbr>HTTP</abbr> a été conçu pour optimiser la mise en cache. Il y
a une catégorie entière d'appareils (nommés « proxy de cache ») dont le
seul rôle est d'être l'intermédiaire entre vous et le reste du monde
pour minimiser l'accès au réseau. Votre entreprise ou <abbr>FAI</abbr>
utilise certainement ce type de proxy, même si vous ne le savez pas.
Ces appareils fonctionnent parce que la mise en cache est un des
fondements du <abbr>HTTP</abbr>.
</p>
<p>Voici un exemple pour démontrer le fonctionnement de la mise en cache. Vous visitez <a href="http://diveintomark.org/"><code>diveintomark.org</code></a> avec votre navigateur. Cette page contient une image de fond, <a href="http://wearehugh.com/m.jpg"><code>wearehugh.com/m.jpg</code></a>.
Quand votre navigateur télécharge cette image, le serveur envoie les en-tête <abbr>HTTP</abbr> suivantes:
</p>

<pre class="nd"><code>HTTP/1.1 200 OK<br>Date: Sun, 31 May 2009 17:14:04 GMT<br>Server: Apache<br>Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT<br>ETag: "3075-ddc8d800"<br>Accept-Ranges: bytes<br>Content-Length: 12405<br><mark>Cache-Control: max-age=31536000, public</mark><br><mark>Expires: Mon, 31 May 2010 17:14:04 GMT</mark><br>Connection: close<br>Content-Type: image/jpeg</code></pre>

<p>Les en-tête <code>Cache-Control</code> et <code>Expires</code> annoncent à votre navigateur (et proxys de cache entre le serveur et vous) que cette image peut être mise en cache pour un an. <span style="font-style: italic;">Un an!</span> <em></em>Et
si, pendant cette année vous visitez une autre page qui inclut
également un lien vers cette image, votre navigateur chargera l'image
depuis son cache, <span style="font-style: italic;">sans générer la moindre activité sur le réseau</span>.
</p>
<p>Mais attendez, il y a mieux. Imaginons que votre navigateur supprime
l'image de votre cache local pour une raison quelconque. Il manque
peut-être de l'espace sur le disque, ou vous avez vidé le cache
manuellement, peu importe. Mais les en-têtes <abbr>HTTP</abbr>
disaient que ces données pouvaient être mises en cache par les proxys
de cache publiques (techniquement, c'est ce que les en-têtes ne disent
pas qui est important; l'en-tête <code>Cache-Control</code> ne contient pas le mot clef <code>private</code>,
donc ces données peuvent être mises en cache, par défaut). Les proxys
de cache sont conçus pour disposer d'énormes espaces de stockage, sans
doute bien plus que votre navigateur.
</p>
<p>Si votre entreprise ou <abbr>FAI</abbr> utilise un proxy de cache, l'image y est peut-être toujours. Quand vous visitez <code>diveintomark.org</code>
à nouveau, votre navigateur cherchera l'image dans son cache local,
mais ne la trouvera pas. Il enverra alors une requête pour tenter
d'obtenir l'image depuis le serveur. Mais si le proxy de cache a encore
une copie de l'image, il interceptera la requête et renverra l'image
depuis <span style="font-style: italic;">son</span> cache. Ça signifie
que votre requête n'arrivera jamais au serveur distant. En fait, elle
ne quittera même pas le réseau de votre entreprise. Ça a pour effet
d'accélérer le téléchargement (moins de traffic réseau) et économise
l'argent de votre entreprise (moins de données téléchargées depuis le
monde extérieur).
</p>
<p>La mise en cache <abbr>HTTP</abbr> ne peut fonctionner que si tout
le monde fait son travail. D'une part, les serveurs doivent envoyer les
en-têtes appropriées dans leur réponse. D'autre part, les clients
doivent comprendre et respecter ces en-têtes avant de demander deux
fois les mêmes données. Les proxys intermédiaires ne sont pas la
panacée, il ne peuvent être plus intelligents que les serveurs et
clients ne le permettent.
</p>
<p>Les librairies <abbr>HTTP</abbr> de Python ne supportent pas la mise en cache, mais <code>httplib2</code> le fait.
</p>

<h3 id="last-modified">La vérification de dernière modification<br>
</h3>

<p>Certaines données ne changent jamais. D'autres changent tout le temps. Entre les deux, il y a un large éventail de données qui <span style="font-style: italic;">pourraient</span>
avoir changé, mais n'ont pas changé. Le flux de CNN.com est mis à jour
presque chaque minute, mais celui de mon blog peut ne pas changer
pendant des jours, voire des semaines. Dans ce dernier cas, il ne faut
pourtant pas dire aux clients de mettre ce flux en cache pour des
semaines. Autrement, lorsque je publierai quelque chose, les gens
pourraient ne pas le lire pendant des semaines (parce qu'ils respectent
mes en-têtes de cache qui disaient « ne prenez pas la peine de vérifier
ce flux pendant des semaines »). D'un autre côté, je n'ai pas envie que
des clients téléchargent l'entièreté de mon flux toutes les heures s'il
n'a pas changé!
<aside><code>304: Not Modified</code> signifie “même merde, autre jour.”</aside>
</p>
<p><abbr>HTTP</abbr> a une solution pour ça aussi. Quand vois demandez des données pour la première fois, le serveur peut vous renvoyer une en-tête <code>Last-Modified</code>
(dernière modification). C'est exactement ce que ça dit: la date à
laquelle ces données ont été modifiées pour la dernière fois. Cette
image de fond référencée depuis <code>diveintomark.org</code> incluait une en-tête <code>Last-Modified</code>.
</p>
<pre class="nd"><code>HTTP/1.1 200 OK<br>Date: Sun, 31 May 2009 17:14:04 GMT<br>Server: Apache<br><mark>Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT</mark><br>ETag: "3075-ddc8d800"<br>Accept-Ranges: bytes<br>Content-Length: 12405<br>Cache-Control: max-age=31536000, public<br>Expires: Mon, 31 May 2010 17:14:04 GMT<br>Connection: close<br>Content-Type: image/jpeg<br></code></pre>

<p>Quand vous demandez ces données une deuxième (ou troisième ou quatrième) fois, vous pouvez envoyer une en-tête <code>If-Modified-Since</code>
avec votre requête, accompagné de la date que vous avez reçu du serveur
la dernière fois. Si les donées ont changé depuis, le serveur ignore
l'en-tête <code>If-Modified-Since</code>
et vous donne simplement les nouvelles données avec un code de statut <code>200</code>. Mais si les données n'ont pas changé, le serveur renvoie le code de statut <abbr>HTTP</abbr> <code>304</code>,
qui signifie « ces données n'ont pas changé depuis la dernière fois que
vous les avez demandées ». Vous pouvez tester ça en ligne de comande,
en utilisant <a href="http://curl.haxx.se/">curl</a>:
</p>

<pre class="nd screen"><samp class="p">you@localhost:~$ </samp><kbd>curl -I <mark>-H "If-Modified-Since: Fri, 22 Aug 2008 04:28:16 GMT"</mark> http://wearehugh.com/m.jpg</kbd><br><samp>HTTP/1.1 304 Not Modified<br>Date: Sun, 31 May 2009 18:04:39 GMT<br>Server: Apache<br>Connection: close<br>ETag: "3075-ddc8d800"<br>Expires: Mon, 31 May 2010 18:04:39 GMT<br>Cache-Control: max-age=31536000, public</samp></pre>

<p>Pourquoi est-ce une amélioration ? Parce que quand le serveur envoie un <code>304</code>, <span style="font-style: italic;">il ne renvoie pas les données</span>.
Tout ce que vous recevez est le code de statut. Même après que votre
copie en cache ait expiré, la vérification de dernière modification
assure que vous ne téléchargiez pas deux fois les mêmes données si
elles n'ont pas changé. (En bonus, cette réponse <code>304</code>
inclut également des en-têtes de mise en cache. Les proxys garderont
une copie des données&nbsp; même après qu'elles aient officiellement «
expiré », dans l'espoir que les données n'aient pas <span style="font-style: italic;">réellement</span> changé et que la requête suivante réponde avec un code de statut <code>304</code> et des informations de mise en cache à jour.)
</p>

<p>Les librairies <abbr>HTTP</abbr> de Python ne supportent pas la vérification de dernière modification, mais <code>httplib2</code> le fait.
</p>

<h3 id="etags">ETag Checking</h3>

<p>ETags are an alternate way to accomplish the same thing as the <a href="#last-modified">last-modified checking</a>. With Etags, the
server sends a hash code in an <code>ETag</code> header along with the
data you requested. (Exactly how this hash is determined is entirely up
to the server. The only requirement is that it changes when the data
changes.) That background image referenced from <code>diveintomark.org</code>
had an <code>ETag</code> header.
</p>

<pre class="nd"><code>HTTP/1.1 200 OK<br>Date: Sun, 31 May 2009 17:14:04 GMT<br>Server: Apache<br>Last-Modified: Fri, 22 Aug 2008 04:28:16 GMT<br><mark>ETag: "3075-ddc8d800"</mark><br>Accept-Ranges: bytes<br>Content-Length: 12405<br>Cache-Control: max-age=31536000, public<br>Expires: Mon, 31 May 2010 17:14:04 GMT<br>Connection: close<br>Content-Type: image/jpeg<br></code></pre>

<aside><code>ETag</code> means “there’s nothing new under the sun.”</aside>
<p>The second time you request the same data, you include the ETag hash
in an <code>If-None-Match</code> header of your request. If the data
hasn’t changed, the server will send you back a <code>304</code>
status code. As with the last-modified date checking, the server sends
back <em>only</em> the <code>304</code> status code; it doesn’t send
you the same data a second time. By including the ETag hash in your
second request, you’re telling the server that there’s no need to
re-send the same data if it still matches this hash, since <a href="#caching">you still have the data from the last time</a>.
</p>

<p>Again with the <kbd>curl</kbd>:
</p>

<pre class="nd screen"><a><samp class="p">you@localhost:~$ </samp><kbd>curl -I <mark>-H "If-None-Match: \"3075-ddc8d800\""</mark> http://wearehugh.com/m.jpg</kbd>  <span class="u">①</span></a><br><samp>HTTP/1.1 304 Not Modified<br>Date: Sun, 31 May 2009 18:04:39 GMT<br>Server: Apache<br>Connection: close<br>ETag: "3075-ddc8d800"<br>Expires: Mon, 31 May 2010 18:04:39 GMT<br>Cache-Control: max-age=31536000, public</samp></pre>

<ol>

  <li>ETags are commonly enclosed in quotation marks, but <em>the
quotation marks are part of the value</em>. That means you need to send
the quotation marks back to the server in the <code>If-None-Match</code>
header.
  </li>
</ol>

<p>Python’s <abbr>HTTP</abbr> libraries do not support ETags, but <code>httplib2</code>
does.
</p>

<h3 id="compression">Compression</h3>

<p>When you talk about <abbr>HTTP</abbr> web services, you’re almost
always talking about moving text-based data back and forth over the
wire. Maybe it’s <abbr>XML</abbr>, maybe it’s <abbr>JSON</abbr>,
maybe it’s just <a href="strings.html#boring-stuff" title="there ain’t no such thing as plain text">plain text</a>.
Regardless of the format, text compresses well. The example feed in <a href="xml.html">the XML chapter</a> is 3070 bytes uncompressed, but
would be 941 bytes after gzip compression. That’s just 30% of the
original size!
</p>

<p><abbr>HTTP</abbr> supports <a href="http://www.iana.org/assignments/http-parameters">several
compression algorithms</a>. The two most common types are <a href="http://www.ietf.org/rfc/rfc1952.txt">gzip</a> and <a href="http://www.ietf.org/rfc/rfc1951.txt">deflate</a>. When you
request a resource over <abbr>HTTP</abbr>, you can ask the server to
send it in compressed format. You include an <code>Accept-encoding</code>
header in your request that lists which compression algorithms you
support. If the server supports any of the same algorithms, it will
send you back compressed data (with a <code>Content-encoding</code>
header that tells you which algorithm it used). Then it’s up to you to
decompress the data.
</p>

<blockquote class="note">
  <p><span class="u">☞</span>Important tip for server-side developers:
make sure that the compressed version of a resource has a different <a href="#etags">Etag</a> than the uncompressed version. Otherwise,
caching proxies will get confused and may serve the compressed version
to clients that can’t handle it. Read the discussion of <a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=39727">Apache
bug 39727</a> for more details on this subtle issue.
  </p>
</blockquote>

<p>Python’s <abbr>HTTP</abbr> libraries do not support compression,
but <code>httplib2</code> does.
</p>

<h3 id="redirects">Redirects</h3>

<p><a href="http://www.w3.org/Provider/Style/URI">Cool <abbr>URI</abbr>s
don’t change</a>, but many <abbr>URI</abbr>s are seriously uncool. Web
sites get reorganized, pages move to new addresses. Even web services
can reorganize. A syndicated feed at <code>http://example.com/index.xml</code>
might be moved to <code>http://example.com/xml/atom.xml</code>. Or an
entire domain might move, as an organization expands and reorganizes; <code>http://www.example.com/index.xml</code>
becomes <code>http://server-farm-1.example.com/index.xml</code>.
<aside><code>Location</code> means “look over there!”</aside>
</p>

<p>Every time you request any kind of resource from an <abbr>HTTP</abbr>
server, the server includes a status code in its response. Status code <code>200</code>
means “everything’s normal, here’s the page you asked for”. Status code
<code>404</code> means “page not found”. (You’ve probably seen 404
errors while browsing the web.) Status codes in the 300’s indicate some
form of redirection.
</p>

<p><abbr>HTTP</abbr> has several different ways of signifying that a
resource has moved. The two most common techiques are status codes <code>302</code>
and <code>301</code>. Status code <code>302</code> is a <i>temporary
redirect</i>; it means “oops, that got moved over here temporarily”
(and then gives the temporary address in a <code>Location</code>
header). Status code <code>301</code> is a <i>permanent redirect</i>;
it means “oops, that got moved permanently” (and then gives the new
address in a <code>Location</code> header). If you get a <code>302</code>
status code and a new address, the <abbr>HTTP</abbr> specification
says you should use the new address to get what you asked for, but the
next time you want to access the same resource, you should retry the
old address. But if you get a <code>301</code> status code and a new
address, you’re supposed to use the new address from then on.
</p>

<p>The <code>urllib.request</code> module automatically “follow”
redirects when it receives the appropriate status code from the <abbr>HTTP</abbr>
server, but it doesn’t tell you that it did so. You’ll end up getting
data you asked for, but you’ll never know that the underlying library
“helpfully” followed a redirect for you. So you’ll continue pounding
away at the old address, and each time you’ll get redirected to the new
address, and each time the <code>urllib.request</code> module will
“helpfully” follow the redirect. In other words, it treats permanent
redirects the same as temporary redirects. That means two round trips
instead of one, which is bad for the server and bad for you.
</p>

<p><code>httplib2</code> handles permanent redirects for you. Not only
will it tell you that a permanent redirect occurred, it will keep track
of them locally and automatically rewrite redirected <abbr>URL</abbr>s
before requesting them.
</p>

<p class="a">⁂
</p>

<h2 id="dont-try-this-at-home">How Not To Fetch Data Over HTTP</h2>

<p>Let’s say you want to download a resource over <abbr>HTTP</abbr>,
such as <a href="xml.html">an Atom feed</a>. Being a feed, you’re not
just going to download it once; you’re going to download it over and
over again. (Most feed readers will check for changes once an hour.)
Let’s do it the quick-and-dirty way first, and then see how you can do
better.
</p>

<pre class="nd screen"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">import urllib.request</kbd><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">a_url = 'http://diveintopython3.org/examples/feed.xml'</kbd><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">data = urllib.request.urlopen(a_url).read()</kbd>  <span class="u">①</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">type(data)</kbd>                                   <span class="u">②</span></a><br><samp class="pp">&lt;class 'bytes'&gt;</samp><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">print(data)</kbd><br><samp class="pp">&lt;?xml version='1.0' encoding='utf-8'?&gt;<br>&lt;feed xmlns='http://www.w3.org/2005/Atom' xml:lang='en'&gt;<br>  &lt;title&gt;dive into mark&lt;/title&gt;<br>  &lt;subtitle&gt;currently between addictions&lt;/subtitle&gt;<br>  &lt;id&gt;tag:diveintomark.org,2001-07-29:/&lt;/id&gt;<br>  &lt;updated&gt;2009-03-27T21:56:07Z&lt;/updated&gt;<br>  &lt;link rel='alternate' type='text/html' href='http://diveintomark.org/'/&gt;<br>  …<br></samp></pre>

<ol>

  <li>Downloading anything over <abbr>HTTP</abbr> is incredibly easy
in Python; in fact, it’s a one-liner. The <code>urllib.request</code>
module has a handy <code>urlopen()</code> function that takes the
address of the page you want, and returns a file-like object that you
can just <code>read()</code> from to get the full contents of the
page. It just can’t get any easier.
  </li>
  <li>The <code>urlopen().read()</code> method always returns <a href="strings.html#byte-arrays">a <code>bytes</code> object, not a
string</a>. Remember, bytes are bytes; characters are an abstraction. <abbr>HTTP</abbr>
servers don’t deal in abstractions. If you request a resource, you get
bytes. If you want it as a string, you’ll need to <a href="http://feedparser.org/docs/character-encoding.html">determine
the character encoding</a> and explicitly convert it to a string.
  </li>
</ol>

<p>So what’s wrong with this? For a quick one-off during testing or
development, there’s nothing wrong with it. I do it all the time. I
wanted the contents of the feed, and I got the contents of the feed.
The same technique works for any web page. But once you start thinking
in terms of a web service that you want to access on a regular basis (<i>e.g.</i>
requesting this feed once an hour), then you’re being inefficient, and
you’re being rude.
</p>

<p class="a">⁂
</p>

<h2 id="whats-on-the-wire">What’s On The Wire?</h2>

<p>To see why this is inefficient and rude, let’s turn on the debugging
features of Python’s <abbr>HTTP</abbr> library and see what’s being
sent “on the wire” (<i>i.e.</i> over the network).
</p>

<pre class="screen"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">from http.client import HTTPConnection</kbd><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">HTTPConnection.debuglevel = 1</kbd>                                       <span class="u">①</span></a><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">from urllib.request import urlopen</kbd><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response = urlopen('http://diveintopython3.org/examples/feed.xml')</kbd>  <span class="u">②</span></a><br><samp><a>send: b'GET /examples/feed.xml HTTP/1.1                                 <span class="u">③</span></a><br><a>Host: diveintopython3.org                                               <span class="u">④</span></a><br><a>Accept-Encoding: identity                                               <span class="u">⑤</span></a><br><a>User-Agent: Python-urllib/3.1'                                          <span class="u">⑥</span></a><br>Connection: close<br>reply: 'HTTP/1.1 200 OK'<br>…further debugging information omitted…</samp></pre>

<ol>

  <li>As I mentioned at the beginning of the chapter, <code>urllib.request</code>
relies on another standard Python library, <code>http.client</code>.
Normally you don’t need to touch <code>http.client</code> directly.
(The <code>urllib.request</code> module imports it automatically.) But
we import it here so we can toggle the debugging flag on the <code>HTTPConnection</code>
class that <code>urllib.request</code> uses to connect to the <abbr>HTTP</abbr>
server.
  </li>
  <li>Now that the debugging flag is set, information on the <abbr>HTTP</abbr>
request and response is printed out in real time. As you can see, when
you request the Atom feed, the <code>urllib.request</code> module
sends five lines to the server.
  </li>
  <li>The first line specifies the <abbr>HTTP</abbr> verb you’re
using, and the path of the resource (minus the domain name).
  </li>
  <li>The second line specifies the domain name from which we’re
requesting this feed.
  </li>
  <li>The third line specifies the compression algorithms that the
client supports. As I mentioned earlier, <a href="#compression"><code>urllib.request</code>
does not support compression</a> by default.
  </li>
  <li>The fourth line specifies the name of the library that is making
the request. By default, this is <code>Python-urllib</code> plus a
version number. Both <code>urllib.request</code> and <code>httplib2</code>
support changing the user agent, simply by adding a <code>User-Agent</code>
header to the request (which will override the default value).
  </li>
</ol>

<aside>We’re downloading 3070 bytes when we could have just downloaded
941.</aside>
<p>Now let’s look at what the server sent back in its response.
</p>

<pre class="screen"># continued from previous example<br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">print(response.headers.as_string())</kbd>        <span class="u">①</span></a><br><samp><a>Date: Sun, 31 May 2009 19:23:06 GMT            <span class="u">②</span></a><br>Server: Apache<br><a>Last-Modified: Sun, 31 May 2009 06:39:55 GMT   <span class="u">③</span></a><br><a>ETag: "bfe-93d9c4c0"                           <span class="u">④</span></a><br>Accept-Ranges: bytes<br><a>Content-Length: 3070                           <span class="u">⑤</span></a><br><a>Cache-Control: max-age=86400                   <span class="u">⑥</span></a><br>Expires: Mon, 01 Jun 2009 19:23:06 GMT<br>Vary: Accept-Encoding<br>Connection: close<br>Content-Type: application/xml</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">data = response.read()</kbd>                     <span class="u">⑦</span></a><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">len(data)</kbd><br><samp class="pp">3070</samp></pre>

<ol>

  <li>The <var>response</var> returned from the <code>urllib.request.urlopen()</code>
function contains all the <abbr>HTTP</abbr> headers the server sent
back. It also contains methods to download the actual data; we’ll get
to that in a minute.
  </li>
  <li>The server tells you when it handled your request.
  </li>
  <li>This response includes a <a href="#last-modified"><code>Last-Modified</code></a>
header.
  </li>
  <li>This response includes an <a href="#etags"><code>ETag</code></a>
header.
  </li>
  <li>The data is 3070 bytes long. Notice what <em>isn’t</em> here: a <code>Content-encoding</code>
header. Your request stated that you only accept uncompressed data (<code>Accept-encoding:
identity</code>), and sure enough, this response contains uncompressed
data.
  </li>
  <li>This response includes caching headers that state that this feed
can be cached for up to 24 hours (86400 seconds).
  </li>
  <li>And finally, download the actual data by calling <code>response.read()</code>.
As you can tell from the <code>len()</code> function, this downloads
all 3070 bytes at once.
  </li>
</ol>

<p>As you can see, this code is already inefficient: it asked for (and
received) uncompressed data. I know for a fact that this server
supports <a href="#compression">gzip compression</a>, but <abbr>HTTP</abbr>
compression is opt-in. We didn’t ask for it, so we didn’t get it. That
means we’re downloading 3070 bytes when we could have just downloaded
941. Bad dog, no biscuit.
</p>

<p>But wait, it gets worse! To see just how inefficient this code is,
let’s request the same feed a second time.
</p>

<pre class="nd screen"># continued from the <a href="#whats-on-the-wire">previous example</a><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response2 = urlopen('http://diveintopython3.org/examples/feed.xml')</kbd><br><samp>send: b'GET /examples/feed.xml HTTP/1.1<br>Host: diveintopython3.org<br>Accept-Encoding: identity<br>User-Agent: Python-urllib/3.1'<br>Connection: close<br>reply: 'HTTP/1.1 200 OK'<br>…further debugging information omitted…</samp></pre>

<p>Notice anything peculiar about this request? It hasn’t changed! It’s
exactly the same as the first request. No sign of <a href="#last-modified"><code>If-Modified-Since</code> headers</a>. No
sign of <a href="#etags"><code>If-None-Match</code> headers</a>. No
respect for the caching headers. Still no compression.
</p>

<p>And what happens when you do the same thing twice? You get the same
response. Twice.
</p>

<pre class="screen"># continued from the previous example<br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">print(response2.headers.as_string())</kbd>     <span class="u">①</span></a><br><samp>Date: Mon, 01 Jun 2009 03:58:00 GMT<br>Server: Apache<br>Last-Modified: Sun, 31 May 2009 22:51:11 GMT<br>ETag: "bfe-255ef5c0"<br>Accept-Ranges: bytes<br>Content-Length: 3070<br>Cache-Control: max-age=86400<br>Expires: Tue, 02 Jun 2009 03:58:00 GMT<br>Vary: Accept-Encoding<br>Connection: close<br>Content-Type: application/xml</samp><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">data2 = response2.read()</kbd><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">len(data2)</kbd>                               <span class="u">②</span></a><br><samp class="pp">3070</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">data2 == data</kbd>                            <span class="u">③</span></a><br><samp class="pp">True</samp></pre>

<ol>

  <li>The server is still sending the same array of “smart” headers: <code>Cache-Control</code>
and <code>Expires</code> to allow caching, <code>Last-Modified</code>
and <code>ETag</code> to enable “not-modified” tracking. Even the <code>Vary:
Accept-Encoding</code> header hints that the server would support
compression, if only you would ask for it. But you didn’t.
  </li>
  <li>Once again, fetching this data downloads the whole 3070 bytes…
  </li>
  <li>…the exact same 3070 bytes you downloaded last time.
  </li>
</ol>

<p><abbr>HTTP</abbr> is designed to work better than this. <code>urllib</code>
speaks <abbr>HTTP</abbr> like I speak Spanish&nbsp;—&nbsp;enough to
get by in a jam, but not enough to hold a conversation. <abbr>HTTP</abbr>
is a conversation. It’s time to upgrade to a library that speaks <abbr>HTTP</abbr>
fluently.
</p>

<p class="a">⁂
</p>

<h2 id="introducing-httplib2">Introducing <code>httplib2</code></h2>

<p>Before you can use <code>httplib2</code>, you’ll need to install
it. Visit <a href="http://code.google.com/p/httplib2/"><code>code.google.com/p/httplib2/</code></a>
and download the latest version. <code>httplib2</code> is available
for Python 2.x and Python 3.x; make sure you get the Python 3 version,
named something like <code>httplib2-python3-0.5.0.zip</code>.
</p>

<p>Unzip the archive, open a terminal window, and go to the newly
created <code>httplib2</code> directory. On Windows, open the <code>Start</code>
menu, select <code>Run...</code>, type <kbd>cmd.exe</kbd> and press <kbd>ENTER</kbd>.
</p>

<pre class="screen"><samp class="p">c:\Users\pilgrim\Downloads&gt; </samp><kbd><mark>dir</mark></kbd><br><samp> Volume in drive C has no label.<br> Volume Serial Number is DED5-B4F8<br><br> Directory of c:\Users\pilgrim\Downloads<br><br>07/28/2009  12:36 PM    &lt;DIR&gt;          .<br>07/28/2009  12:36 PM    &lt;DIR&gt;          ..<br>07/28/2009  12:36 PM    &lt;DIR&gt;          httplib2-python3-0.5.0<br>07/28/2009  12:33 PM            18,997 httplib2-python3-0.5.0.zip<br>               1 File(s)         18,997 bytes<br>               3 Dir(s)  61,496,684,544 bytes free</samp><br><br><samp class="p">c:\Users\pilgrim\Downloads&gt; </samp><kbd><mark>cd httplib2-python3-0.5.0</mark></kbd><br><samp class="p">c:\Users\pilgrim\Downloads\httplib2-python3-0.5.0&gt; </samp><kbd><mark>c:\python31\python.exe setup.py install</mark></kbd><br><samp>running install<br>running build<br>running build_py<br>running install_lib<br>creating c:\python31\Lib\site-packages\httplib2<br>copying build\lib\httplib2\iri2uri.py -&gt; c:\python31\Lib\site-packages\httplib2<br>copying build\lib\httplib2\__init__.py -&gt; c:\python31\Lib\site-packages\httplib2<br>byte-compiling c:\python31\Lib\site-packages\httplib2\iri2uri.py to iri2uri.pyc<br>byte-compiling c:\python31\Lib\site-packages\httplib2\__init__.py to __init__.pyc<br>running install_egg_info<br>Writing c:\python31\Lib\site-packages\httplib2-python3_0.5.0-py3.1.egg-info</samp></pre>

<p>On Mac OS X, run the <code>Terminal.app</code> application in your <code>/Applications/Utilities/</code>
folder. On Linux, run the <code>Terminal</code> application, which is
usually in your <code>Applications</code> menu under <code>Accessories</code>
or <code>System</code>.
</p>

<pre class="screen cmdline"><samp class="p">you@localhost:~/Desktop$ </samp><kbd><mark>unzip httplib2-python3-0.5.0.zip</mark></kbd><br><samp>Archive:  httplib2-python3-0.5.0.zip<br>  inflating: httplib2-python3-0.5.0/README<br>  inflating: httplib2-python3-0.5.0/setup.py<br>  inflating: httplib2-python3-0.5.0/PKG-INFO<br>  inflating: httplib2-python3-0.5.0/httplib2/__init__.py<br>  inflating: httplib2-python3-0.5.0/httplib2/iri2uri.py</samp><br><samp class="p">you@localhost:~/Desktop$ </samp><kbd><mark>cd httplib2-python3-0.5.0/</mark></kbd><br><samp class="p">you@localhost:~/Desktop/httplib2-python3-0.5.0$ </samp><kbd><mark>sudo python3 setup.py install</mark></kbd><br><samp>running install<br>running build<br>running build_py<br>creating build<br>creating build/lib.linux-x86_64-3.1<br>creating build/lib.linux-x86_64-3.1/httplib2<br>copying httplib2/iri2uri.py -&gt; build/lib.linux-x86_64-3.1/httplib2<br>copying httplib2/__init__.py -&gt; build/lib.linux-x86_64-3.1/httplib2<br>running install_lib<br>creating /usr/local/lib/python3.1/dist-packages/httplib2<br>copying build/lib.linux-x86_64-3.1/httplib2/iri2uri.py -&gt; /usr/local/lib/python3.1/dist-packages/httplib2<br>copying build/lib.linux-x86_64-3.1/httplib2/__init__.py -&gt; /usr/local/lib/python3.1/dist-packages/httplib2<br>byte-compiling /usr/local/lib/python3.1/dist-packages/httplib2/iri2uri.py to iri2uri.pyc<br>byte-compiling /usr/local/lib/python3.1/dist-packages/httplib2/__init__.py to __init__.pyc<br>running install_egg_info<br>Writing /usr/local/lib/python3.1/dist-packages/httplib2-python3_0.5.0.egg-info</samp></pre>

<p>To use <code>httplib2</code>, create an instance of the <code>httplib2.Http</code>
class.
</p>

<pre class="screen"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">import httplib2</kbd><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">h = httplib2.Http('.cache')</kbd>                                                    <span class="u">①</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response, content = h.request('http://diveintopython3.org/examples/feed.xml')</kbd>  <span class="u">②</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response.status</kbd>                                                                <span class="u">③</span></a><br><samp class="pp">200</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">content[:52]</kbd>                                                                   <span class="u">④</span></a><br><samp class="pp">b"&lt;?xml version='1.0' encoding='utf-8'?&gt;\r\n&lt;feed xmlns="</samp><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">len(content)</kbd><br><samp class="pp">3070</samp></pre>

<ol>

  <li>The primary interface to <code>httplib2</code> is the <code>Http</code>
object. For reasons you’ll see in the next section, you should always
pass a directory name when you create an <code>Http</code> object. The
directory does not need to exist; <code>httplib2</code> will create it
if necessary.
  </li>
  <li>Once you have an <code>Http</code> object, retrieving data is as
simple as calling the <code>request()</code> method with the address
of the data you want. This will issue an <abbr>HTTP</abbr> <code>GET</code>
request for that <abbr>URL</abbr>. (Later in this chapter, you’ll see
how to issue other <abbr>HTTP</abbr> requests, like <code>POST</code>.)
  </li>
  <li>The <code>request()</code> method returns two values. The first
is an <code>httplib2.Response</code> object, which contains all the <abbr>HTTP</abbr>
headers the server returned. For example, a <code>status</code> code
of <code>200</code> indicates that the request was successful.
  </li>
  <li>The <var>content</var> variable contains the actual data that
was returned by the <abbr>HTTP</abbr> server. The data is returned as <a href="strings.html#byte-arrays">a <code>bytes</code> object, not a
string</a>. If you want it as a string, you’ll need to <a href="http://feedparser.org/docs/character-encoding.html">determine
the character encoding</a> and convert it yourself.
  </li>
</ol>

<blockquote class="note">
  <p><span class="u">☞</span>You probably only need one <code>httplib2.Http</code>
object. There are valid reasons for creating more than one, but you
should only do so if you know why you need them. “I need to request
data from two different <abbr>URL</abbr>s” is not a valid reason.
Re-use the <code>Http</code> object and just call the <code>request()</code>
method twice.
  </p>
</blockquote>

<h3 id="why-bytes">A Short Digression To Explain Why <code>httplib2</code>
Returns Bytes Instead of Strings</h3>

<p>Bytes. Strings. What a pain. Why can’t <code>httplib2</code> “just”
do the conversion for you? Well, it’s complicated, because the rules
for determining the character encoding are specific to what kind of
resource you’re requesting. How could <code>httplib2</code> know what
kind of resource you’re requesting? It’s usually listed in the <code>Content-Type</code>
<abbr>HTTP</abbr> header, but that’s an optional feature of <abbr>HTTP</abbr>
and not all <abbr>HTTP</abbr> servers include it. If that header is
not included in the <abbr>HTTP</abbr> response, it’s left up to the
client to guess. (This is commonly called “content sniffing,” and it’s
never perfect.)
</p>

<p>If you know what sort of resource you’re expecting (an <abbr>XML</abbr>
document in this case), perhaps you could “just” pass the returned <code>bytes</code>
object to the <a href="xml.html#xml-parse"><code>xml.etree.ElementTree.parse()</code>
function</a>. That’ll work as long as the <abbr>XML</abbr> document
includes information on its own character encoding (as this one does),
but that’s an optional feature and not all <abbr>XML</abbr> documents
do that. If an <abbr>XML</abbr> document doesn’t include encoding
information, the client is supposed to look at the enclosing
transport&nbsp;—&nbsp;<i>i.e.</i> the <code>Content-Type</code> <abbr>HTTP</abbr>
header, which can include a <code>charset</code> parameter.
</p>

<p class="ss"><a style="border: 0pt none ;" href="http://www.cafepress.com/feedparser"><img src="http://feedparser.org/img/feedparser.jpg" alt="[I support RFC 3023 t-shirt]" height="150" width="150"></a></p>

<p>But it’s worse than that. Now character encoding information can be
in two places: within the <abbr>XML</abbr> document itself, and within
the <code>Content-Type</code> <abbr>HTTP</abbr> header. If the
information is in <em>both</em> places, which one wins? According to <a href="http://www.ietf.org/rfc/rfc3023.txt">RFC 3023</a> (I swear I am
not making this up), if the media type given in the <code>Content-Type</code>
<abbr>HTTP</abbr> header is <code>application/xml</code>, <code>application/xml-dtd</code>,
<code>application/xml-external-parsed-entity</code>, or any one of the
subtypes of <code>application/xml</code> such as <code>application/atom+xml</code>
or <code>application/rss+xml</code> or even <code>application/rdf+xml</code>,
then the encoding is
</p>

<ol>

  <li>the encoding given in the <code>charset</code> parameter of the <code>Content-Type</code>
    <abbr>HTTP</abbr> header, or
  </li>
  <li>the encoding given in the <code>encoding</code> attribute of the
    <abbr>XML</abbr> declaration within the document, or
  </li>
  <li><abbr>UTF-8</abbr>
  </li>
</ol>

<p>On the other hand, if the media type given in the <code>Content-Type</code>
<abbr>HTTP</abbr> header is <code>text/xml</code>, <code>text/xml-external-parsed-entity</code>,
or a subtype like <code>text/AnythingAtAll+xml</code>, then the
encoding attribute of the <abbr>XML</abbr> declaration within the
document is ignored completely, and the encoding is
</p>

<ol>

  <li>the encoding given in the charset parameter of the <code>Content-Type</code>
    <abbr>HTTP</abbr> header, or
  </li>
  <li><code>us-ascii</code>
  </li>
</ol>

<p>And that’s just for <abbr>XML</abbr> documents. For <abbr>HTML</abbr>
documents, web browsers have constructed such <a type="application/pdf" href="http://www.adambarth.com/papers/2009/barth-caballero-song.pdf">byzantine
rules for content-sniffing</a> [<abbr>PDF</abbr>] that <a href="http://www.google.com/search?q=barth+content-type+processing+model">we’re
still trying to figure them all out</a>.
</p>

<p>“<a href="http://code.google.com/p/httplib2/source/checkout">Patches
welcome</a>.”
</p>

<h3 id="httplib2-caching">How <code>httplib2</code> Handles Caching</h3>

<p>Remember in the previous section when I said you should always
create an <code>httplib2.Http</code> object with a directory name?
Caching is the reason.
</p>

<pre class="screen"># continued from the <a href="#introducing-httplib2">previous example</a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response2, content2 = h.request('http://diveintopython3.org/examples/feed.xml')</kbd>  <span class="u">①</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response2.status</kbd>                                                                 <span class="u">②</span></a><br><samp class="pp">200</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">content2[:52]</kbd>                                                                    <span class="u">③</span></a><br><samp class="pp">b"&lt;?xml version='1.0' encoding='utf-8'?&gt;\r\n&lt;feed xmlns="</samp><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">len(content2)</kbd><br><samp class="pp">3070</samp></pre>

<ol>

  <li>This shouldn’t be terribly surprising. It’s the same thing you
did last time, except you’re putting the result into two new variables.
  </li>
  <li>The <abbr>HTTP</abbr> <code>status</code> is once again <code>200</code>,
just like last time.
  </li>
  <li>The downloaded content is the same as last time, too.
  </li>
</ol>

<p>So… who cares? Quit your Python interactive shell and relaunch it
with a new session, and I’ll show you.
</p>

<pre class="screen"># NOT continued from previous example!<br># Please exit out of the interactive shell<br># and launch a new one.<br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">import httplib2</kbd><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">httplib2.debuglevel = 1</kbd>                                                        <span class="u">①</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">h = httplib2.Http('.cache')</kbd>                                                    <span class="u">②</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response, content = h.request('http://diveintopython3.org/examples/feed.xml')</kbd>  <span class="u">③</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">len(content)</kbd>                                                                   <span class="u">④</span></a><br><samp class="pp">3070</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response.status</kbd>                                                                <span class="u">⑤</span></a><br><samp class="pp">200</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response.fromcache</kbd>                                                             <span class="u">⑥</span></a><br><samp class="pp">True</samp></pre>

<ol>

  <li>Let’s turn on debugging and see <a href="#whats-on-the-wire">what’s
on the wire</a>. This is the <code>httplib2</code> equivalent of
turning on debugging in <code>http.client</code>. <code>httplib2</code>
will print all the data being sent to the server and some key
information being sent back.
  </li>
  <li>Create an <code>httplib2.Http</code> object with the same
directory name as before.
  </li>
  <li>Request the same <abbr>URL</abbr> as before. <em>Nothing
appears to happen.</em> More precisely, nothing gets sent to the
server, and nothing gets returned from the server. There is absolutely
no network activity whatsoever.
  </li>
  <li>Yet we did “receive” some data&nbsp;—&nbsp;in fact, we received
all of it.
  </li>
  <li>We also “received” an <abbr>HTTP</abbr> status code indicating
that the “request” was successful.
  </li>
  <li>Here’s the rub: this “response” was generated from <code>httplib2</code>’s
local cache. That directory name you passed in when you created the <code>httplib2.Http</code>
object&nbsp;—&nbsp;that directory holds <code>httplib2</code>’s cache
of all the operations it’s ever performed.
  </li>
</ol>

<aside>What’s on the wire? Absolutely nothing.</aside>
<blockquote class="note">
  <p><span class="u">☞</span>If you want to turn on <code>httplib2</code>
debugging, you need to set a module-level constant (<code>httplib2.debuglevel</code>),
then create a new <code>httplib2.Http</code> object. If you want to
turn off debugging, you need to change the same module-level constant,
then create a new <code>httplib2.Http</code> object.
  </p>
</blockquote>

<p>You previously requested the data at this <abbr>URL</abbr>. That
request was successful (<code>status: 200</code>). That response
included not only the feed data, but also a set of <a href="#caching">caching
headers</a> that told anyone who was listening that they could cache
this resource for up to 24 hours (<code>Cache-Control: max-age=86400</code>,
which is 24 hours measured in seconds). <code>httplib2</code>
understand and respects those caching headers, and it stored the
previous response in the <code>.cache</code> directory (which you
passed in when you create the <code>Http</code> object). That cache
hasn’t expired yet, so the second time you request the data at this <abbr>URL</abbr>,
<code>httplib2</code> simply returns the cached result without ever
hitting the network.
</p>

<p>I say “simply,” but obviously there is a lot of complexity hidden
behind that simplicity. <code>httplib2</code> handles <abbr>HTTP</abbr>
caching <em>automatically</em> and <em>by default</em>. If for some
reason you need to know whether a response came from the cache, you can
check <code>response.fromcache</code>. Otherwise, it Just Works.
</p>

<p id="bypass-the-cache">Now, suppose you have data cached, but you
want to bypass the cache and re-request it from the remote server.
Browsers sometimes do this if the user specifically requests it. For
example, pressing <kbd>F5</kbd> refreshes the current page, but
pressing <kbd>Ctrl+F5</kbd> bypasses the cache and re-requests the
current page from the remote server. You might think “oh, I’ll just
delete the data from my local cache, then request it again.” You could
do that, but remember that there may be more parties involved than just
you and the remote server. What about those intermediate proxy servers?
They’re completely beyond your control, and they may still have that
data cached, and will happily return it to you because (as far as they
are concerned) their cache is still valid.
</p>

<p>Instead of manipulating your local cache and hoping for the best,
you should use the features of <abbr>HTTP</abbr> to ensure that your
request actually reaches the remote server.
</p>

<pre class="screen"># continued from the previous example<br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response2, content2 = h.request('http://diveintopython3.org/examples/feed.xml',</kbd><br><a><samp class="p">... </samp><kbd class="pp">    headers={'cache-control':'no-cache'})</kbd>  <span class="u">①</span></a><br><samp><a>connect: (diveintopython3.org, 80)             <span class="u">②</span></a><br>send: b'GET /examples/feed.xml HTTP/1.1<br>Host: diveintopython3.org<br>user-agent: Python-httplib2/$Rev: 259 $<br>accept-encoding: deflate, gzip<br>cache-control: no-cache'<br>reply: 'HTTP/1.1 200 OK'<br>…further debugging information omitted…</samp><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response2.status</kbd><br><samp class="pp">200</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response2.fromcache</kbd>                        <span class="u">③</span></a><br><samp class="pp">False</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">print(dict(response2.items()))</kbd>             <span class="u">④</span></a><br><samp class="pp">{'status': '200',<br> 'content-length': '3070',<br> 'content-location': 'http://diveintopython3.org/examples/feed.xml',<br> 'accept-ranges': 'bytes',<br> 'expires': 'Wed, 03 Jun 2009 00:40:26 GMT',<br> 'vary': 'Accept-Encoding',<br> 'server': 'Apache',<br> 'last-modified': 'Sun, 31 May 2009 22:51:11 GMT',<br> 'connection': 'close',<br> '-content-encoding': 'gzip',<br> 'etag': '"bfe-255ef5c0"',<br> 'cache-control': 'max-age=86400',<br> 'date': 'Tue, 02 Jun 2009 00:40:26 GMT',<br> 'content-type': 'application/xml'}</samp></pre>

<ol>

  <li><code>httplib2</code> allows you to add arbitrary <abbr>HTTP</abbr>
headers to any outgoing request. In order to bypass <em>all</em>
caches (not just your local disk cache, but also any caching proxies
between you and the remote server), add a <code>no-cache</code> header
in the <var>headers</var> dictionary.
  </li>
  <li>Now you see <code>httplib2</code> initiating a network request. <code>httplib2</code>
understands and respects caching headers <em>in both directions</em>&nbsp;—&nbsp;as
part of the incoming response <em>and as part of the outgoing request</em>.
It noticed that you added the <code>no-cache</code> header, so it
bypassed its local cache altogether and then had no choice but to hit
the network to request the data.
  </li>
  <li>This response was <em>not</em> generated from your local cache.
You knew that, of course, because you saw the debugging information on
the outgoing request. But it’s nice to have that programmatically
verified.
  </li>
  <li>The request succeeded; you downloaded the entire feed again from
the remote server. Of course, the server also sent back a full
complement of <abbr>HTTP</abbr> headers along with the feed data. That
includes caching headers, which <code>httplib2</code> uses to update
its local cache, in the hopes of avoiding network access the <em>next</em>
time you request this feed. Everything about <abbr>HTTP</abbr> caching
is designed to maximize cache hits and minimize network access. Even
though you bypassed the cache this time, the remote server would really
appreciate it if you would cache the result for next time.
  </li>
</ol>

<h3 id="httplib2-etags">How <code>httplib2</code> Handles <code>Last-Modified</code>
and <code>ETag</code> Headers</h3>

<p>The <code>Cache-Control</code> and <code>Expires</code> <a href="#caching">caching headers</a> are called <i>freshness indicators</i>.
They tell caches in no uncertain terms that you can completely avoid
all network access until the cache expires. And that’s exactly the
behavior you saw <a href="#httplib2-caching">in the previous section</a>:
given a freshness indicator, <code>httplib2</code> <em>does not
generate a single byte of network activity</em> to serve up cached data
(unless you explicitly <a href="#bypass-the-cache">bypass the cache</a>,
of course).
</p>

<p>But what about the case where the data <em>might</em> have changed,
but hasn’t? <abbr>HTTP</abbr> defines <a href="#last-modified"><code>Last-Modified</code></a>
and <a href="#etags"><code>Etag</code></a> headers for this purpose.
These headers are called <i>validators</i>. If the local cache is no
longer fresh, a client can send the validators with the next request to
see if the data has actually changed. If the data hasn’t changed, the
server sends back a <code>304</code> status code <em>and no data</em>.
So there’s still a round-trip over the network, but you end up
downloading fewer bytes.
</p>

<pre class="screen"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">import httplib2</kbd><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">httplib2.debuglevel = 1</kbd><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">h = httplib2.Http('.cache')</kbd><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response, content = h.request('http://diveintopython3.org/')</kbd>  <span class="u">①</span></a><br><samp>connect: (diveintopython3.org, 80)<br>send: b'GET / HTTP/1.1<br>Host: diveintopython3.org<br>accept-encoding: deflate, gzip<br>user-agent: Python-httplib2/$Rev: 259 $'<br>reply: 'HTTP/1.1 200 OK'</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">print(dict(response.items()))</kbd>                                 <span class="u">②</span></a><br><samp class="pp">{'-content-encoding': 'gzip',<br> 'accept-ranges': 'bytes',<br> 'connection': 'close',<br> 'content-length': '6657',<br> 'content-location': 'http://diveintopython3.org/',<br> 'content-type': 'text/html',<br> 'date': 'Tue, 02 Jun 2009 03:26:54 GMT',<br><mark> 'etag': '"7f806d-1a01-9fb97900"',</mark><br><mark> 'last-modified': 'Tue, 02 Jun 2009 02:51:48 GMT',</mark><br> 'server': 'Apache',<br> 'status': '200',<br> 'vary': 'Accept-Encoding,User-Agent'}</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">len(content)</kbd>                                                  <span class="u">③</span></a><br><samp class="pp">6657</samp></pre>

<ol>

  <li>Instead of the feed, this time we’re going to download the site’s
home page, which is <abbr>HTML</abbr>. Since this is the first time
you’ve ever requested this page, <code>httplib2</code> has little to
work with, and it sends out a minimum of headers with the request.
  </li>
  <li>The response contains a multitude of <abbr>HTTP</abbr> headers…
but no caching information. However, it does include both an <code>ETag</code>
and <code>Last-Modified</code> header.
  </li>
  <li>At the time I constructed this example, this page was 6657 bytes.
It’s probably changed since then, but don’t worry about it.
  </li>
</ol>

<pre class="screen"># continued from the previous example<br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response, content = h.request('http://diveintopython3.org/')</kbd>  <span class="u">①</span></a><br><samp>connect: (diveintopython3.org, 80)<br>send: b'GET / HTTP/1.1<br>Host: diveintopython3.org<br><a>if-none-match: "7f806d-1a01-9fb97900"                             <span class="u">②</span></a><br><a>if-modified-since: Tue, 02 Jun 2009 02:51:48 GMT                  <span class="u">③</span></a><br>accept-encoding: deflate, gzip<br>user-agent: Python-httplib2/$Rev: 259 $'<br><a>reply: 'HTTP/1.1 304 Not Modified'                                <span class="u">④</span></a></samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response.fromcache</kbd>                                            <span class="u">⑤</span></a><br><samp class="pp">True</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response.status</kbd>                                               <span class="u">⑥</span></a><br><samp class="pp">200</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response.dict['status']</kbd>                                       <span class="u">⑦</span></a><br><samp class="pp">'304'</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">len(content)</kbd>                                                  <span class="u">⑧</span></a><br><samp class="pp">6657</samp></pre>

<ol>

  <li>You request the same page again, with the same <code>Http</code>
object (and the same local cache).
  </li>
  <li><code>httplib2</code> sends the <code>ETag</code> validator back
to the server in the <code>If-None-Match</code> header.
  </li>
  <li><code>httplib2</code> also sends the <code>Last-Modified</code>
validator back to the server in the <code>If-Modified-Since</code>
header.
  </li>
  <li>The server looked at these validators, looked at the page you
requested, and determined that the page has not changed since you last
requested it, so it sends back a <code>304</code> status code <em>and
no data</em>.
  </li>
  <li>Back on the client, <code>httplib2</code> notices the <code>304</code>
status code and loads the content of the page from its cache.
  </li>
  <li>This might be a bit confusing. There are really <em>two</em>
status codes&nbsp;—&nbsp;<code>304</code> (returned from the server
this time, which caused <code>httplib2</code> to look in its cache),
and <code>200</code> (returned from the server <em>last time</em>,
and stored in <code>httplib2</code>’s cache along with the page data).
    <code>response.status</code> returns the status from the cache.
  </li>
  <li>If you want the raw status code returned from the server, you can
get that by looking in <code>response.dict</code>, which is a
dictionary of the actual headers returned from the server.
  </li>
  <li>However, you still get the data in the <var>content</var>
variable. Generally, you don’t need to know why a response was served
from the cache. (You may not even care that it was served from the
cache at all, and that’s fine too. <code>httplib2</code> is smart
enough to let you act dumb.) By the time the <code>request()</code>
method returns to the caller, <code>httplib2</code> has already
updated its cache and returned the data to you.
  </li>
</ol>

<h3 id="httplib2-compression">How <code>http2lib</code> Handles
Compression</h3>

<aside>“We have both kinds of music, country AND western.”</aside>
<p><abbr>HTTP</abbr> supports <a href="#compression">several types of
compression</a>; the two most common types are gzip and deflate. <code>httplib2</code>
supports both of these.
</p>

<pre class="screen"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response, content = h.request('http://diveintopython3.org/')</kbd><br><samp>connect: (diveintopython3.org, 80)<br>send: b'GET / HTTP/1.1<br>Host: diveintopython3.org<br><a>accept-encoding: deflate, gzip                          <span class="u">①</span></a><br>user-agent: Python-httplib2/$Rev: 259 $'<br>reply: 'HTTP/1.1 200 OK'</samp><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">print(dict(response.items()))</kbd><br><samp class="pp"><a>{'-content-encoding': 'gzip',                           <span class="u">②</span></a><br> 'accept-ranges': 'bytes',<br> 'connection': 'close',<br> 'content-length': '6657',<br> 'content-location': 'http://diveintopython3.org/',<br> 'content-type': 'text/html',<br> 'date': 'Tue, 02 Jun 2009 03:26:54 GMT',<br> 'etag': '"7f806d-1a01-9fb97900"',<br> 'last-modified': 'Tue, 02 Jun 2009 02:51:48 GMT',<br> 'server': 'Apache',<br> 'status': '304',<br> 'vary': 'Accept-Encoding,User-Agent'}</samp></pre>

<ol>

  <li>Every time <code>httplib2</code> sends a request, it includes an
    <code>Accept-Encoding</code> header to tell the server that it can
handle either <code>deflate</code> or <code>gzip</code> compression.
  </li>
  <li>In this case, the server has responded with a gzip-compressed
payload. By the time the <code>request()</code> method returns, <code>httplib2</code>
has already decompressed the body of the response and placed it in the <var>content</var>
variable. If you’re curious about whether or not the response was
compressed, you can check <var>response['-content-encoding']</var>;
otherwise, don’t worry about it.
  </li>
</ol>

<h3 id="httplib2-redirects">How <code>httplib2</code> Handles Redirects</h3>

<p><abbr>HTTP</abbr> defines <a href="#redirects">two kinds of
redirects</a>: temporary and permanent. There’s nothing special to do
with temporary redirects except follow them, which <code>httplib2</code>
does automatically.
</p>

<pre class="screen"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">import httplib2</kbd><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">httplib2.debuglevel = 1</kbd><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">h = httplib2.Http('.cache')</kbd><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response, content = h.request('http://diveintopython3.org/examples/feed-302.xml')</kbd>  <span class="u">①</span></a><br><samp>connect: (diveintopython3.org, 80)<br><a>send: b'GET /examples/feed-302.xml HTTP/1.1                                            <span class="u">②</span></a><br>Host: diveintopython3.org<br>accept-encoding: deflate, gzip<br>user-agent: Python-httplib2/$Rev: 259 $'<br><a>reply: 'HTTP/1.1 302 Found'                                                            <span class="u">③</span></a><br><a>send: b'GET /examples/feed.xml HTTP/1.1                                                <span class="u">④</span></a><br>Host: diveintopython3.org<br>accept-encoding: deflate, gzip<br>user-agent: Python-httplib2/$Rev: 259 $'<br>reply: 'HTTP/1.1 200 OK'</samp></pre>

<ol>

  <li>There is no feed at this <abbr>URL</abbr>. I’ve set up my server
to issue a temporary redirect to the correct address.
  </li>
  <li>There’s the request.
  </li>
  <li>And there’s the response: <code>302 Found</code>. Not shown
here, this response also includes a <code>Location</code> header that
points to the real <abbr>URL</abbr>.
  </li>
  <li><code>httplib2</code> immediately turns around and “follows” the
redirect by issuing another request for the <abbr>URL</abbr> given in
the <code>Location</code> header: <code>http://diveintopython3.org/examples/feed.xml</code>
  </li>
</ol>

<p>“Following” a redirect is nothing more than this example shows. <code>httplib2</code>
sends a request for the <abbr>URL</abbr> you asked for. The server
comes back with a response that says “No no, look over there instead.” <code>httplib2</code>
sends another request for the new <abbr>URL</abbr>.
</p>

<pre class="screen"># continued from the previous example<br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response</kbd>                                                          <span class="u">①</span></a><br><samp class="pp">{'status': '200',<br> 'content-length': '3070',<br><a> 'content-location': 'http://diveintopython3.org/examples/feed.xml',  <span class="u">②</span></a><br> 'accept-ranges': 'bytes',<br> 'expires': 'Thu, 04 Jun 2009 02:21:41 GMT',<br> 'vary': 'Accept-Encoding',<br> 'server': 'Apache',<br> 'last-modified': 'Wed, 03 Jun 2009 02:20:15 GMT',<br> 'connection': 'close',<br><a> '-content-encoding': 'gzip',                                         <span class="u">③</span></a><br> 'etag': '"bfe-4cbbf5c0"',<br><a> 'cache-control': 'max-age=86400',                                    <span class="u">④</span></a><br> 'date': 'Wed, 03 Jun 2009 02:21:41 GMT',<br> 'content-type': 'application/xml'}</samp></pre>

<ol>

  <li>The <var>response</var> you get back from this single call to
the <code>request()</code> method is the response from the final <abbr>URL</abbr>.
  </li>
  <li><code>httplib2</code> adds the final <abbr>URL</abbr> to the <var>response</var>
dictionary, as <code>content-location</code>. This is not a header
that came from the server; it’s specific to <code>httplib2</code>.
  </li>
  <li>Apropos of nothing, this feed is <a href="#httplib2-compression">compressed</a>.
  </li>
  <li>And cacheable. (This is important, as you’ll see in a minute.)
  </li>
</ol>

<p>The <var>response</var> you get back gives you information about
the <em>final</em> <abbr>URL</abbr>. What if you want more
information about the intermediate <abbr>URL</abbr>s, the ones that
eventually redirected to the final <abbr>URL</abbr>? <code>httplib2</code>
lets you do that, too.
</p>

<pre class="screen"># continued from the previous example<br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response.previous</kbd>                                                     <span class="u">①</span></a><br><samp class="pp">{'status': '302',<br> 'content-length': '228',<br> 'content-location': 'http://diveintopython3.org/examples/feed-302.xml',<br> 'expires': 'Thu, 04 Jun 2009 02:21:41 GMT',<br> 'server': 'Apache',<br> 'connection': 'close',<br> 'location': 'http://diveintopython3.org/examples/feed.xml',<br> 'cache-control': 'max-age=86400',<br> 'date': 'Wed, 03 Jun 2009 02:21:41 GMT',<br> 'content-type': 'text/html; charset=iso-8859-1'}</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">type(response)</kbd>                                                        <span class="u">②</span></a><br><samp class="pp">&lt;class 'httplib2.Response'&gt;</samp><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">type(response.previous)</kbd><br><samp class="pp">&lt;class 'httplib2.Response'&gt;</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response.previous.previous</kbd>                                            <span class="u">③</span></a><br><samp class="p">&gt;&gt;&gt;</samp></pre>

<ol>

  <li>The <var>response.previous</var> attribute holds a reference to
the previous response object that <code>httplib2</code> followed to
get to the current response object.
  </li>
  <li>Both <var>response</var> and <var>response.previous</var> are <code>httplib2.Response</code>
objects.
  </li>
  <li>That means you can check <var>response.previous.previous</var>
to follow the redirect chain backwards even further. (Scenario: one <abbr>URL</abbr>
redirects to a second <abbr>URL</abbr> which redirects to a third <abbr>URL</abbr>.
It could happen!) In this case, we’ve already reached the beginning of
the redirect chain, so the attribute is <code>None</code>.
  </li>
</ol>

<p>What happens if you request the same <abbr>URL</abbr> again?
</p>

<pre class="screen"># continued from the previous example<br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response2, content2 = h.request('http://diveintopython3.org/examples/feed-302.xml')</kbd>  <span class="u">①</span></a><br><samp>connect: (diveintopython3.org, 80)<br><a>send: b'GET /examples/feed-302.xml HTTP/1.1                                              <span class="u">②</span></a><br>Host: diveintopython3.org<br>accept-encoding: deflate, gzip<br>user-agent: Python-httplib2/$Rev: 259 $'<br><a>reply: 'HTTP/1.1 302 Found'                                                              <span class="u">③</span></a></samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">content2 == content</kbd>                                                                  <span class="u">④</span></a><br><samp class="pp">True</samp></pre>

<ol>

  <li>Same <abbr>URL</abbr>, same <code>httplib2.Http</code> object
(and therefore the same cache).
  </li>
  <li>The <code>302</code> response was not cached, so <code>httplib2</code>
sends another request for the same <abbr>URL</abbr>.
  </li>
  <li>Once again, the server responds with a <code>302</code>. But
notice what <em>didn’t</em> happen: there wasn’t ever a second request
for the final <abbr>URL</abbr>, <code>http://diveintopython3.org/examples/feed.xml</code>.
That response was cached (remember the <code>Cache-Control</code>
header that you saw in the previous example). Once <code>httplib2</code>
received the <code>302 Found</code> code, <em>it checked its cache
before issuing another request</em>. The cache contained a fresh copy
of <code>http://diveintopython3.org/examples/feed.xml</code>, so there
was no need to re-request it.
  </li>
  <li>By the time the <code>request()</code> method returns, it has
read the feed data from the cache and returned it. Of course, it’s the
same as the data you received last time.
  </li>
</ol>

<p>In other words, you don’t have to do anything special for temporary
redirects. <code>httplib2</code> will follow them automatically, and
the fact that one <abbr>URL</abbr> redirects to another has no bearing
on <code>httplib2</code>’s support for compression, caching, <code>ETags</code>,
or any of the other features of <abbr>HTTP</abbr>.
</p>

<p>Permanent redirects are just as simple.
</p>

<pre class="screen"># continued from the previous example<br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response, content = h.request('http://diveintopython3.org/examples/feed-301.xml')</kbd>  <span class="u">①</span></a><br><samp>connect: (diveintopython3.org, 80)<br>send: b'GET /examples/feed-301.xml HTTP/1.1<br>Host: diveintopython3.org<br>accept-encoding: deflate, gzip<br>user-agent: Python-httplib2/$Rev: 259 $'<br><a>reply: 'HTTP/1.1 301 Moved Permanently'                                                <span class="u">②</span></a></samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response.fromcache</kbd>                                                                 <span class="u">③</span></a><br><samp class="pp">True</samp></pre>

<ol>

  <li>Once again, this <abbr>URL</abbr> doesn’t really exist. I’ve set
up my server to issue a permanent redirect to <code>http://diveintopython3.org/examples/feed.xml</code>.
  </li>
  <li>And here it is: status code <code>301</code>. But again, notice
what <em>didn’t</em> happen: there was no request to the redirect <abbr>URL</abbr>.
Why not? Because it’s already cached locally.
  </li>
  <li><code>httplib2</code> “followed” the redirect right into its
cache.
  </li>
</ol>

<p>But wait! There’s more!
</p>

<pre class="screen"># continued from the previous example<br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response2, content2 = h.request('http://diveintopython3.org/examples/feed-301.xml')</kbd>  <span class="u">①</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">response2.fromcache</kbd>                                                                  <span class="u">②</span></a><br><samp class="pp">True</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">content2 == content</kbd>                                                                  <span class="u">③</span></a><br><samp class="pp">True</samp>
</pre>

<ol>

  <li>Here’s the difference between temporary and permanent redirects:
once <code>httplib2</code> follows a permanent redirect, all further
requests for that <abbr>URL</abbr> will transparently be rewritten to
the target <abbr>URL</abbr> <em>without hitting the network for the
original <abbr>URL</abbr></em>. Remember, debugging is still turned
on, yet there is no output of network activity whatsoever.
  </li>
  <li>Yep, this response was retrieved from the local cache.
  </li>
  <li>Yep, you got the entire feed (from the cache).
  </li>
</ol>

<p><abbr>HTTP</abbr>. It works.
</p>

<p class="a">⁂
</p>

<h2 id="beyond-get">Beyond HTTP GET</h2>

<p><abbr>HTTP</abbr> web services are not limited to <code>GET</code>
requests. What if you want to create something new? Whenever you post a
comment on a discussion forum, update your weblog, publish your status
on a microblogging service like <a href="http://twitter.com/">Twitter</a>
or <a href="http://identi.ca/">Identi.ca</a>, you’re probably already
using <abbr>HTTP</abbr> <code>POST</code>.
</p>

<p>Both Twitter and Identi.ca both offer a simple <abbr>HTTP</abbr>-based
<abbr>API</abbr> for publishing and updating your status in 140
characters or less. Let’s look at <a href="http://laconi.ca/trac/wiki/TwitterCompatibleAPI">Identi.ca’s <abbr>API</abbr>
documentation</a> for updating your status:
</p>

<blockquote class="pf">
  <p><b>Identi.ca <abbr>REST</abbr> <abbr>API</abbr> Method:
statuses/update</b><br>
Updates the authenticating user’s status. Requires the <code>status</code>
parameter specified below. Request must be a <code>POST</code>.
  </p>
  <dl>
    <dt><abbr>URL</abbr>
    </dt>
    <dd><code>https://identi.ca/api/statuses/update.<i><var>format</var></i></code>
    </dd>
    <dt>Formats
    </dt>
    <dd><code>xml</code>, <code>json</code>, <code>rss</code>, <code>atom</code>
    </dd>
    <dt><abbr>HTTP</abbr> Method(s)
    </dt>
    <dd><code>POST</code>
    </dd>
    <dt>Requires Authentication
    </dt>
    <dd>true
    </dd>
    <dt>Parameters
    </dt>
    <dd><code>status</code>. Required. The text of your status update. <abbr>URL</abbr>-encode
as necessary.
    </dd>
  </dl>
</blockquote>

<p>How does this work? To publish a new message on Identi.ca, you need
to issue an <abbr>HTTP</abbr> <code>POST</code> request to <code>http://identi.ca/api/statuses/update.<i>format</i></code>.
(The <var>format</var> bit is not part of the <abbr>URL</abbr>; you
replace it with the data format you want the server to return in
response to your request. So if you want a response in <abbr>XML</abbr>,
you would post the request to <code>https://identi.ca/api/statuses/update.xml</code>.)
The request needs to include a parameter called <code>status</code>,
which contains the text of your status update. And the request needs to
be authenticated.
</p>

<p>Authenticated? Sure. To update your status on Identi.ca, you need to
prove who you are. Identi.ca is not a wiki; only you can update your
own status. Identi.ca uses <a href="http://en.wikipedia.org/wiki/Basic_access_authentication"><abbr>HTTP</abbr>
Basic Authentication</a> (<i>a.k.a.</i> <a href="http://www.ietf.org/rfc/rfc2617.txt">RFC 2617</a>) over <abbr>SSL</abbr>
to provide secure but easy-to-use authentication. <code>httplib2</code>
supports both <abbr>SSL</abbr> and <abbr>HTTP</abbr> Basic
Authentication, so this part is easy.
</p>

<p>A <code>POST</code> request is different from a <code>GET</code>
request, because it includes a <i>payload</i>. The payload is the data
you want to send to the server. The one piece of data that this <abbr>API</abbr>
method <em>requires</em> is <code>status</code>, and it should be <i><abbr>URL</abbr>-encoded</i>.
This is a very simple serialization format that takes a set of
key-value pairs (<i>i.e.</i> a <a href="native-datatypes.html#dictionaries">dictionary</a>) and
transforms it into a string.
</p>

<pre class="screen"><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">from urllib.parse import urlencode</kbd>              <span class="u">①</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">data = {'status': 'Test update from Python 3'}</kbd>  <span class="u">②</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">urlencode(data)</kbd>                                 <span class="u">③</span></a><br><samp>'status=Test+update+from+Python+3'</samp></pre>

<ol>

  <li>Python comes with a utility function to <abbr>URL</abbr>-encode
a dictionary: <code>urllib.parse.urlencode()</code>.
  </li>
  <li>This is the sort of dictionary that the Identi.ca <abbr>API</abbr>
is looking for. It contains one key, <code>status</code>, whose value
is the text of a single status update.
  </li>
  <li>This is what the <abbr>URL</abbr>-encoded string looks like.
This is the <i>payload</i> that will be sent “on the wire” to the
Identi.ca <abbr>API</abbr> server in your <abbr>HTTP</abbr> <code>POST</code>
request.
  </li>
</ol>

<p>
</p>

<pre class="screen"><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">from urllib.parse import urlencode</kbd><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">import httplib2</kbd><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">httplib2.debuglevel = 1</kbd><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">h = httplib2.Http('.cache')</kbd><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">data = {'status': 'Test update from Python 3'}</kbd><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">h.add_credentials('diveintomark', '<var>MY_SECRET_PASSWORD</var>', 'identi.ca')</kbd>    <span class="u">①</span></a><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">resp, content = h.request('https://identi.ca/api/statuses/update.xml',</kbd><br><a><samp class="p">... </samp><kbd class="pp">    'POST',</kbd>                                                             <span class="u">②</span></a><br><a><samp class="p">... </samp><kbd class="pp">    urlencode(data),</kbd>                                                    <span class="u">③</span></a><br><a><samp class="p">... </samp><kbd class="pp">    headers={'Content-Type': 'application/x-www-form-urlencoded'})</kbd>      <span class="u">④</span></a></pre>

<ol>

  <li>This is how <code>httplib2</code> handles authentication. Store
your username and password with the <code>add_credentials()</code>
method. When <code>httplib2</code> tries to issue the request, the
server will respond with a <code>401 Unauthorized</code> status code,
and it will list which authentication methods it supports (in the <code>WWW-Authenticate</code>
header). <code>httplib2</code> will automatically construct an <code>Authorization</code>
header and re-request the <abbr>URL</abbr>.
  </li>
  <li>The second parameter is the type of <abbr>HTTP</abbr> request,
in this case <code>POST</code>.
  </li>
  <li>The third parameter is the <i>payload</i> to send to the server.
We’re sending the <abbr>URL</abbr>-encoded dictionary with a status
message.
  </li>
  <li>Finally, we need to tell the server that the payload is <abbr>URL</abbr>-encoded
data.
  </li>
</ol>

<blockquote class="note">
  <p><span class="u">☞</span>The third parameter to the <code>add_credentials()</code>
method is the domain in which the credentials are valid. You should
always specify this! If you leave out the domain and later reuse the <code>httplib2.Http</code>
object on a different authenticated site, <code>httplib2</code> might
end up leaking one site’s username and password to the other site.
  </p>
</blockquote>

<p>This is what goes over the wire:
</p>

<pre class="screen"># continued from the previous example<br><samp>send: b'POST /api/statuses/update.xml HTTP/1.1<br>Host: identi.ca<br>Accept-Encoding: identity<br>Content-Length: 32<br>content-type: application/x-www-form-urlencoded<br>user-agent: Python-httplib2/$Rev: 259 $<br><br>status=Test+update+from+Python+3'<br><a>reply: 'HTTP/1.1 401 Unauthorized'                        <span class="u">①</span></a><br><a>send: b'POST /api/statuses/update.xml HTTP/1.1            <span class="u">②</span></a><br>Host: identi.ca<br>Accept-Encoding: identity<br>Content-Length: 32<br>content-type: application/x-www-form-urlencoded<br><a>authorization: Basic SECRET_HASH_CONSTRUCTED_BY_HTTPLIB2  <span class="u">③</span></a><br>user-agent: Python-httplib2/$Rev: 259 $<br><br>status=Test+update+from+Python+3'<br><a>reply: 'HTTP/1.1 200 OK'                                  <span class="u">④</span></a></samp></pre>

<ol>

  <li>After the first request, the server responds with a <code>401
Unauthorized</code> status code. <code>httplib2</code> will never send
authentication headers unless the server explicitly asks for them. This
is how the server asks for them.
  </li>
  <li><code>httplib2</code> immediately turns around and requests the
same <abbr>URL</abbr> a second time.
  </li>
  <li>This time, it includes the username and password that you added
with the <code>add_credentials()</code> method.
  </li>
  <li>It worked!
  </li>
</ol>

<p>What does the server send back after a successful request? That
depends entirely on the web service <abbr>API</abbr>. In some
protocols (like the <a href="http://www.ietf.org/rfc/rfc5023.txt">Atom
Publishing Protocol</a>), the server sends back a <code>201 Created</code>
status code and the location of the newly created resource in the <code>Location</code>
header. Identi.ca sends back a <code>200 OK</code> and an <abbr>XML</abbr>
document containing information about the newly created resource.
</p>

<pre class="screen"># continued from the previous example<br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">print(content.decode('utf-8'))</kbd>                             <span class="u">①</span></a><br><samp class="pp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>&lt;status&gt;<br><a> &lt;text&gt;Test update from Python 3&lt;/text&gt;                        <span class="u">②</span></a><br> &lt;truncated&gt;false&lt;/truncated&gt;<br> &lt;created_at&gt;Wed Jun 10 03:53:46 +0000 2009&lt;/created_at&gt;<br> &lt;in_reply_to_status_id&gt;&lt;/in_reply_to_status_id&gt;<br> &lt;source&gt;api&lt;/source&gt;<br><a> &lt;id&gt;5131472&lt;/id&gt;                                              <span class="u">③</span></a><br> &lt;in_reply_to_user_id&gt;&lt;/in_reply_to_user_id&gt;<br> &lt;in_reply_to_screen_name&gt;&lt;/in_reply_to_screen_name&gt;<br> &lt;favorited&gt;false&lt;/favorited&gt;<br> &lt;user&gt;<br>  &lt;id&gt;3212&lt;/id&gt;<br>  &lt;name&gt;Mark Pilgrim&lt;/name&gt;<br>  &lt;screen_name&gt;diveintomark&lt;/screen_name&gt;<br>  &lt;location&gt;27502, US&lt;/location&gt;<br>  &lt;description&gt;tech writer, husband, father&lt;/description&gt;<br>  &lt;profile_image_url&gt;http://avatar.identi.ca/3212-48-20081216000626.png&lt;/profile_image_url&gt;<br>  &lt;url&gt;http://diveintomark.org/&lt;/url&gt;<br>  &lt;protected&gt;false&lt;/protected&gt;<br>  &lt;followers_count&gt;329&lt;/followers_count&gt;<br>  &lt;profile_background_color&gt;&lt;/profile_background_color&gt;<br>  &lt;profile_text_color&gt;&lt;/profile_text_color&gt;<br>  &lt;profile_link_color&gt;&lt;/profile_link_color&gt;<br>  &lt;profile_sidebar_fill_color&gt;&lt;/profile_sidebar_fill_color&gt;<br>  &lt;profile_sidebar_border_color&gt;&lt;/profile_sidebar_border_color&gt;<br>  &lt;friends_count&gt;2&lt;/friends_count&gt;<br>  &lt;created_at&gt;Wed Jul 02 22:03:58 +0000 2008&lt;/created_at&gt;<br>  &lt;favourites_count&gt;30768&lt;/favourites_count&gt;<br>  &lt;utc_offset&gt;0&lt;/utc_offset&gt;<br>  &lt;time_zone&gt;UTC&lt;/time_zone&gt;<br>  &lt;profile_background_image_url&gt;&lt;/profile_background_image_url&gt;<br>  &lt;profile_background_tile&gt;false&lt;/profile_background_tile&gt;<br>  &lt;statuses_count&gt;122&lt;/statuses_count&gt;<br>  &lt;following&gt;false&lt;/following&gt;<br>  &lt;notifications&gt;false&lt;/notifications&gt;<br>&lt;/user&gt;<br>&lt;/status&gt;</samp></pre>

<ol>

  <li>Remember, the data returned by <code>httplib2</code> is always <a href="strings.html#byte-arrays">bytes</a>, not a string. To convert it
to a string, you need to decode it using the proper character encoding.
Identi.ca’s <abbr>API</abbr> always returns results in <abbr>UTF-8</abbr>,
so that part is easy.
  </li>
  <li>There’s the text of the status message we just published.
  </li>
  <li>There’s the unique identifier for the new status message.
Identi.ca uses this to construct a <abbr>URL</abbr> for viewing the
message on the web.
  </li>
</ol>

<p>And here it is:
</p>

<p class="c"><img class="fr" src="i/identica-screenshot.png" alt="screenshot showing published status message on Identi.ca" height="449" width="740"></p>

<p class="a">⁂
</p>

<h2 id="beyond-post">Beyond HTTP POST</h2>

<p><abbr>HTTP</abbr> isn’t limited to <code>GET</code> and <code>POST</code>.
Those are certainly the most common types of requests, especially in
web browsers. But web service <abbr>API</abbr>s can go beyond <code>GET</code>
and <code>POST</code>, and <code>httplib2</code> is ready.
</p>

<pre class="screen"># continued from the previous example<br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">from xml.etree import ElementTree as etree</kbd><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">tree = etree.fromstring(content)</kbd>                                          <span class="u">①</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">status_id = tree.findtext('id')</kbd>                                           <span class="u">②</span></a><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">status_id</kbd><br><samp class="pp">'5131472'</samp><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">url = 'https://identi.ca/api/statuses/destroy/{0}.xml'.format(status_id)</kbd>  <span class="u">③</span></a><br><a><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">resp, deleted_content = h.request(url, 'DELETE')</kbd>                          <span class="u">④</span></a></pre>

<ol>

  <li>The server returned <abbr>XML</abbr>, right? You know <a href="xml.html#xml-parse">how to parse <abbr>XML</abbr></a>.
  </li>
  <li>The <code>findtext()</code> method finds the first instance of
the given expression and extracts its text content. In this case, we’re
just looking for an <code>&lt;id&gt;</code> element.
  </li>
  <li>Based on the text content of the <code>&lt;id&gt;</code>
element, we can construct a <abbr>URL</abbr> to delete the status
message we just published.
  </li>
  <li>To delete a message, you simply issue an <abbr>HTTP</abbr> <code>DELETE</code>
request to that <abbr>URL</abbr>.
  </li>
</ol>

<p>This is what goes over the wire:
</p>

<pre class="screen"><samp><a>send: b'DELETE /api/statuses/destroy/5131472.xml HTTP/1.1      <span class="u">①</span></a><br>Host: identi.ca<br>Accept-Encoding: identity<br>user-agent: Python-httplib2/$Rev: 259 $<br><br>'<br><a>reply: 'HTTP/1.1 401 Unauthorized'                             <span class="u">②</span></a><br><a>send: b'DELETE /api/statuses/destroy/5131472.xml HTTP/1.1      <span class="u">③</span></a><br>Host: identi.ca<br>Accept-Encoding: identity<br><a>authorization: Basic SECRET_HASH_CONSTRUCTED_BY_HTTPLIB2       <span class="u">④</span></a><br>user-agent: Python-httplib2/$Rev: 259 $<br><br>'<br><a>reply: 'HTTP/1.1 200 OK'                                       <span class="u">⑤</span></a></samp><br><samp class="p">&gt;&gt;&gt; </samp><kbd class="pp">resp.status</kbd><br><samp class="pp">200</samp></pre>

<ol>

  <li>“Delete this status message.”
  </li>
  <li>“I’m sorry, Dave, I’m afraid I can’t do that.”
  </li>
  <li>“Unauthorized<span class="u" title="interrobang!">‽</span> Hmmph.
Delete this status message, <em>please</em>…
  </li>
  <li>…and here’s my username and password.”
  </li>
  <li>“Consider it done!”
  </li>
</ol>

<p>And just like that, poof, it’s gone.
</p>

<p class="c"><img class="fr" src="i/identica-deleted.png" alt="screenshot showing deleted message on Identi.ca" height="449" width="740"></p>

<p class="a">⁂
</p>

<h2 id="furtherreading">Further Reading</h2>

<p><code>httplib2</code>:
</p>

<ul>

  <li><a href="http://code.google.com/p/httplib2/"><code>httplib2</code>
project page</a>
  </li>
  <li><a href="http://code.google.com/p/httplib2/wiki/ExamplesPython3">More
    <code>httplib2</code> code examples</a>
  </li>
  <li><a href="http://www.xml.com/pub/a/2006/02/01/doing-http-caching-right-introducing-httplib2.html">Doing
    <abbr>HTTP</abbr> Caching Right: Introducing <code>httplib2</code></a>
  </li>
  <li><a href="http://www.xml.com/pub/a/2006/03/29/httplib2-http-persistence-and-authentication.html"><code>httplib2</code>:
    <abbr>HTTP</abbr> Persistence and Authentication</a>
  </li>
</ul>

<p><abbr>HTTP</abbr> caching:
</p>

<ul>

  <li><a href="http://www.mnot.net/cache_docs/"><abbr>HTTP</abbr>
Caching Tutorial</a> by Mark Nottingham
  </li>
  <li><a href="http://code.google.com/p/doctype/wiki/ArticleHttpCaching">How
to control caching with <abbr>HTTP</abbr> headers</a> on Google
Doctype
  </li>
</ul>

<p><abbr>RFC</abbr>s:
</p>

<ul>

  <li><a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616: <abbr>HTTP</abbr></a>
  </li>
  <li><a href="http://www.ietf.org/rfc/rfc2617.txt">RFC 2617: <abbr>HTTP</abbr>
Basic Authentication</a>
  </li>
  <li><a href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951: deflate
compression</a>
  </li>
  <li><a href="http://www.ietf.org/rfc/rfc1952.txt">RFC 1952: gzip
compression</a>
  </li>
</ul>

<p class="v"><a rel="prev" href="serializing.html" title="back to “Serializing Python Objects”"><span class="u">☜</span></a>
<a rel="next" href="case-study-porting-chardet-to-python-3.html" title="onward to “Case Study: Porting chardet to Python 3”"><span class="u">☞</span></a>
</p>

<p class="c">© 2001–10 <a href="about.html">Mark Pilgrim</a>
<script src="j/jquery.js"></script>
<script src="j/prettify.js"></script>
<script src="j/dip3.js"></script></p>

</body></html>