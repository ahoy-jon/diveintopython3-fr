<!DOCTYPE html>
<meta charset=utf-8>
<title>It&eacute;rateurs avanc&eacute;s - Plongez au c&oelig;ur de Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 8}
mark{display:inline}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Vous &ecirc;tes ici: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#advanced-iterators>Dive Into Python 3</a> <span class=u>&#8227;</span>
<p id=level>Niveau de difficult&eacute;: <span class=u title=advanced>&#x2666;&#x2666;&#x2666;&#x2666;&#x2662;</span>
<h1>It&eacute;rateurs avanc&eacute;s</h1>
<blockquote class=q>
    <p><span class=u>&#x275D;</span> Les grosses puces ont des petites puces sur leurs dos pour les mordrent, les petites puces ont des puces encore plus petites, et ainsi de suite &agrave; l&#8217;infini. <span class=u>&#x275E;</span><br>&mdash; Augustus De Morgan
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Lan&ccedil;ons nous</h2>
<p class=f>Tout comme les <a href=regular-expressions.html>expressions r&eacute;guli&egrave;res</a> boostent <a href=strings.html>les cha&icirc;nes de caract&egrave;res</a>, le module <code>itertools</code> boostent les <a href=iterators.html>it&eacute;rateurs</a>. Mais en premier lieu, je veux vous montrer un puzzle classique.

<pre class=nd><code>HAWAII + IDAHO + IOWA + OHIO == STATES
510199 + 98153 + 9301 + 3593 == 621246

H = 5
A = 1
W = 0
I = 9
D = 8
O = 3
S = 6
T = 2
E = 4</code></pre>

<p>Les puzzles de ce genre sont appel&eacute;s des <i>cryptarithmes</i> ou des <i>alpham&eacute;tiques</i> (<a href="glossaire.html#cryptarithme">ndlt</a>: un cryptarithme, aussi connu sous les noms d'arithm&eacute;tique verbale, d&#8217;alpham&eacute;tique et de cryptarithm&eacute;tique, est un casse-t&ecirc;te num&eacute;rique et logique qui consiste en une &eacute;quation math&eacute;matique o&ugrave; les lettres repr&eacute;sentent des chiffres &agrave; trouver). Les lettres &eacute;pellent des mots r&eacute;els, mais si vous remplacez chaque lettre par un chiffre situ&eacute; dans l&#8217;intervalle <code>0&ndash;9</code>, cela "correspond" &eacute;galement &agrave; une &eacute;quation arithm&eacute;tique. L&#8217;astuce est de trouver quelle lettre est repr&eacute;sent&eacute;e par quel chiffre. Toutes les occurrences de chaque lettre doivent &ecirc;tre repr&eacute;sent&eacute;e par le m&ecirc;me chiffre, aucun chiffre ne peut être r&eacute;p&eacute;t&eacute; et aucun &#8220;mot&#8221; ne peut commencer par le chiffre 0.

<aside>Le puzzle alpham&eacute;tique le plus connu est <code>SEND + MORE = MONEY</code>.</aside>

<p>Dans ce chapitre, nous allons plonger dans un programme Python incroyable, initialement &eacute;crit par Raymond Hettinger. Ce programme r&eacute;sout des &eacute;nigmes alpham&eacute;tiques <em>en seulement 14 lignes de code</em>.

<p class=d>[<a href=examples/alphametics.py>download <code>alphametics.py</code></a>]
<pre class=pp><code>import re
import itertools

def solve(puzzle):
    words = re.findall('[A-Z]+', puzzle.upper())
    unique_characters = set(''.join(words))
    assert len(unique_characters) &lt;= 10, 'Too many letters'
    first_letters = {word[0] for word in words}
    n = len(first_letters)
    sorted_characters = ''.join(first_letters) + \
        ''.join(unique_characters - first_letters)
    characters = tuple(ord(c) for c in sorted_characters)
    digits = tuple(ord(c) for c in '0123456789')
    zero = digits[0]
    for guess in itertools.permutations(digits, len(characters)):
        if zero not in guess[:n]:
            equation = puzzle.translate(dict(zip(characters, guess)))
            if eval(equation):
                return equation

if __name__ == '__main__':
    import sys
    for puzzle in sys.argv[1:]:
        print(puzzle)
        solution = solve(puzzle)
        if solution:
            print(solution)</code></pre>

<p>Vous pouvez ex&eacute;cuter le programme &agrave; partir de la ligne de commande. Sur Linux, cela pourrait ressembler &agrave; ceci. (Cela peut parfois prendre du temps en fonction de la vitesse de votre ordinateur, et il n&#8217;y a aucune barre de progression. Soyez seulement patient!)

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "HAWAII + IDAHO + IOWA + OHIO == STATES"</kbd>
<samp>HAWAII + IDAHO + IOWA + OHIO = STATES
510199 + 98153 + 9301 + 3593 == 621246</samp>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "I + LOVE + YOU == DORA"</kbd>
<samp>I + LOVE + YOU == DORA
1 + 2784 + 975 == 3760</samp>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "SEND + MORE == MONEY"</kbd>
<samp>SEND + MORE == MONEY
9567 + 1085 == 10652</samp></pre>

<p class=a>&#x2042;

<h2 id=re-findall>Trouver toutes les occurrences d&#8217;un pattern</h2>

<p>La premi&egrave;re chose que fait ce solveur alpham&eacute;tique est de trouver toutes les lettres (A&ndash;Z) dans le puzzle.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.findall('[0-9]+', '16 2-by-4s in rows of 8')</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>['16', '2', '4', '8']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.findall('[A-Z]+', 'SEND + MORE == MONEY')</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>['SEND', 'MORE', 'MONEY']</samp></pre>
<ol>
<li>Le module <code>re</code> est une impl&eacute;mentation Python des <a href=regular-expressions.html>expressions r&eacute;guli&egrave;res</a>. Il comprend une fonction astucieuse appel&eacute;e <code>findall()</code> qui prend en param&egrave;tre une expression r&eacute;guli&egrave;re et une cha&icirc;ne de caract&egrave;res, et trouve toutes les occurences du motif recherch&eacute; &agrave; l&#8217;int&eacute;rieur de la cha&icirc;ne de caract&egrave;res. Dans ce cas-ci, le motif correspopnd &agrave; des s&eacute;quences de nombres. La fonction <code>findall()</code> retourne une liste de toutes les sous-cha&icirc;nes de caract&egrave;res qui correspondent au motif recherch&eacute;.
<li>Voici l&#8217;expression r&eacute;guli&egrave;re correspondant aux s&eacute;quences de lettres. Une fois encore, la valeur de retour est une liste et chaque &eacute;l&eacute;ment de la liste est une cha&icirc;ne de caract&egrave;res qui correspond &agrave; l&#8217;expression r&eacute;guli&egrave;re.
</ol>

<p>Voici un autre exemple qui va mettre un petit peu votre cerveau &agrave; contribution.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>re.findall(' s.*? s', "The sixth sick sheikh's sixth sheep's sick.")</kbd>
<samp class=pp>[' sixth s', " sheikh's s", " sheep's s"]</samp></pre>

<aside>Ceci est le <a href=http://en.wikipedia.org/wiki/Tongue-twister>virelangue <a href="glossaire.html#virelangue">(ndlt)</a> le plus difficile</a> de la langue anglaise.</aside>

<p>Surpris? L&#8217;expression r&eacute;guli&egrave;re recherche un espace, un <code>s</code>, puis une s&eacute;rie de caract&egrave;res la plus courte possible (<code>.*?</code>), puis un espace, puis un autre <code>s</code>. Enfin, en regardant la cha&icirc;ne de caract&egrave;res pass&eacute;e en entr&eacute;e, je distingue cinq occurences:

<ol>
<li><code>The<mark> sixth s</mark>ick sheikh's sixth sheep's sick.</code>
<li><code>The sixth<mark> sick s</mark>heikh's sixth sheep's sick.</code>
<li><code>The sixth sick<mark> sheikh's s</mark>ixth sheep's sick.</code>
<li><code>The sixth sick sheikh's<mark> sixth s</mark>heep's sick.</code>
<li><code>The sixth sick sheikh's sixth<mark> sheep's s</mark>ick.</code>
</ol>

<p>Mais la fonction <code>re.findall()</code> ne retourne que trois occurences. Plus pr&eacute;cis&eacute;ment, elle a renvoy&eacute; la premi&egrave;re, la troisi&egrave;me et la cinqui&egrave;me. Pourquoi cela? Parcequ&#8217;elle <em>ne retourne pas les cas qui se superposent</em>. La premi&egrave;re occurence chevauche la seconde, la premi&egrave;re est donc retourn&eacute;e et la seconde ignor&eacute;e. Puis la troisi&egrave;me chevauche la quatri&egrave;me, la troisi&egrave;me est donc retourn&eacute;e et la quatri&egrave;me ignor&eacute;e. Finalement, la cinqui&egrave;me est retourn&eacute;e. Trois occurences, pas cinq.

<p>Cela n&#8217;a rien &agrave; voir avec le solveur alpham&eacute;tique; J&#8217;ai juste pens&eacute; que c&#8217;&eacute;tait int&eacute;ressant.

<p class=a>&#x2042;

<h2 id=unique-items>Trouver les &eacute;l&eacute;ments distincts dans une s&eacute;quence</h2>

<p>Les <a href=native-datatypes.html#sets>sets</a> rendent triviale la recherche des &eacute;l&eacute;ments distincts dans une s&eacute;quence.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['The', 'sixth', 'sick', "sheik's", 'sixth', "sheep's", 'sick']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>set(a_list)</kbd>                      <span class=u>&#x2460;</span></a>
<samp class=pp>{'sixth', 'The', "sheep's", 'sick', "sheik's"}</samp>
<samp class=p>>>> </samp><kbd class=pp>a_string = 'EAST IS EAST'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>set(a_string)</kbd>                    <span class=u>&#x2461;</span></a>
<samp class=pp>{'A', ' ', 'E', 'I', 'S', 'T'}</samp>
<samp class=p>>>> </samp><kbd class=pp>words = ['SEND', 'MORE', 'MONEY']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>''.join(words)</kbd>                   <span class=u>&#x2462;</span></a>
<samp class=pp>'SENDMOREMONEY'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>set(''.join(words))</kbd>              <span class=u>&#x2463;</span></a>
<samp class=pp>{'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</samp></pre>
<ol>
<li>&Eacute;tant donn&eacute; une liste de plusieurs cha&icirc;nes de caract&egrave;res, la fonction <code>set()</code> retournera un ensemble de cha&icirc;nes de caract&egrave;res distincts de la liste. Cela prend tout son sens si vous y pensez comme &agrave; une boucle <code>for</code>. Prenez le premier &eacute;l&eacute;ment de la liste, mettez le dans le set. Le second. Le troisi&egrave;me. Le quatri&egrave;me. Le cinqui&egrave;me&nbsp;&mdash;&nbsp;attendez, celui l&agrave; est d&eacute;j&agrave; dans le set, par cons&eacute;quent il ne sera list&eacute; qu&#8217;une seule fois parce que les sets Python ne permettent pas les doublons. Le sixi&egrave;me. Le septi&egrave;me&nbsp;&mdash;&nbsp;encore une fois, un doublon, il ne sera donc list&eacute; qu&#8217;une fois. Le r&eacute;sultat final? Tous les &eacute;l&eacute;ments de la liste originale list&eacute;s une fois, sans aucun doublon. La liste initiale n&#8217;a m&ecirc;me pas besoin d&#8217;&ecirc;tre tri&eacute;e en premier.
<li>La m&ecirc;me technique fonctionne aussi avec les cha&icirc;nes de caract&egrave;res puisqu&#8217;une cha&icirc;ne de caract&egrave;res est tout simplement une s&eacute;quence de caract&egrave;res.
<li>&Eacute;tant donn&eacute; une liste de cha&icirc;nes de caract&egrave;res, <code>''.join(<var>a_list</var>)</code> concat&egrave;ne toutes les cha&icirc;nes de caract&egrave;res en une seule.
<li>Donc, &eacute;tant donn&eacute; une liste de cha&icirc;nes de  caract&egrave;res, cette ligne de code renvoie tous les caract&egrave;res distincts utilis&eacute;s dans les cha&icirc;nes de caract&egrave;res, sans aucun doublon.
</ol>

<p>Le solveur alpham&eacute;tique utilise cette technique pour construire un ensemble de tous les caract&egrave;res distincts du puzzle.

<pre class='nd pp'><code>unique_characters = set(''.join(words))</code></pre>

<p>Cette liste est ensuite utilis&eacute;e pour attribuer des chiffres aux caract&egrave;res alors que le solveur parcourt les solutions possibles.

<p class=a>&#x2042;

<h2 id=assert>R&eacute;aliser une assertion</h2>

<p>Comme de nombreux langages de programmation, Python a une instruction  <code>assert</code>. Voici comment elle fonctionne.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>assert 1 + 1 == 2</kbd>                                     <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>assert 1 + 1 == 3</kbd>                                     <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AssertionError</samp>
<a><samp class=p>>>> </samp><kbd class=pp>assert 2 + 2 == 5, "Only for very large values of 2"</kbd>  <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AssertionError: Only for very large values of 2</samp></pre>
<ol>
<li>L&#8217;affirmation <code>assert</code> est suivie de n&#8217;importe quelle expression Python valide. Dans ce cas-ci, l&#8217;expression <code>1 + 1 == 2</code> est &eacute;valu&eacute;e &agrave; <code>True</code>, l&#8217;affirmation <code>assert</code> ne fait donc rien.
<li>Toutefois, si l&#8217;expression Python retourne <code>False</code>, l&#8217;affirmation <code>assert</code> d&eacute;clenchera une <code>AssertionError</code>.
<li>Vous pouvez &eacute;galement inclure un message lisible par le commun des mortels qui est imprim&eacute; si l&#8217;erreur <code>AssertionError</code> est soulevée.
</ol>

<p>Par cons&eacute;quent, cette ligne de code:

<pre class='nd pp'><code>assert len(unique_characters) &lt;= 10, 'Too many letters'</code></pre>

<p>&hellip;est &eacute;quivalente &agrave; celle-ci:

<pre class='nd pp'><code>if len(unique_characters) > 10:
    raise AssertionError('Too many letters')</code></pre>

<p>Le solveur alpham&eacute;tique utilise cette affirmation exacte <code>assert</code> pour pr&eacute;venir des cas o&ugrave; le puzzle contient plus de dix lettres distinctes. Comme chaque lettre se voit attribuer un chiffre distinct et qu&#8217;il ya seulement dix chiffres, un puzzle avec plus de dix lettres distinctes ne peut pas avoir de solution.

<p class=a>&#x2042;

<h2 id=generator-expressions>Expression g&eacute;n&eacute;ratrice</h2>

<p>Une expression g&eacute;n&eacute;ratrice est comme une <a href=generators.html>fonction g&eacute;n&eacute;ratrice</a> mais sans la fonction.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>unique_characters = {'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>gen = (ord(c) for c in unique_characters)</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>gen</kbd>                                        <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;generator object &lt;genexpr> at 0x00BADC10></samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(gen)</kbd>                                  <span class=u>&#x2462;</span></a>
<samp class=pp>69</samp>
<samp class=p>>>> </samp><kbd class=pp>next(gen)</kbd>
<samp class=pp>68</samp>
<a><samp class=p>>>> </samp><kbd class=pp>tuple(ord(c) for c in unique_characters)</kbd>   <span class=u>&#x2463;</span></a>
<samp class=pp>(69, 68, 77, 79, 78, 83, 82, 89)</samp></pre>
<ol>
<li>Une expression g&eacute;n&eacute;ratrice est comme une fonction anonyme qui produit des valeurs. L&#8217;expression elle-m&ecirc;me ressemble &agrave; une <a href=comprehensions.html#listcomprehension>compr&eacute;hension de liste</a>, mais elle est plac&eacute;e entre parenth&egrave;ses plut&ocirc;t qu&#8217;entre des crochets.
<li>L&#8217;expression g&eacute;n&eacute;ratrice retourne&hellip; un it&eacute;rateur.
<li>Un appel &agrave; <code>next(<var>gen</var>)</code> retourne la valeur suivante de l'it&eacute;rateur.
<li>Si vous le souhaitez, vous pouvez parcourir toutes les valeurs possibles et retourner un tuple, une liste, ou un ensemble, en passant l&#8217;expression g&eacute;n&eacute;ratrice &agrave; <code>tuple()</code>, <code>list()</code>, ou <code>set()</code>. Dans ce cas, vous n&#8217;avez pas besoin d&#8217;un jeu de parenth&egrave;ses suppl&eacute;mentaires&nbsp;&mdash;&nbsp;passez juste l&#8217;expression  &#8220;minimum&#8221; <code>ord(c) for c in unique_characters</code> &agrave; la fonction <code>tuple()</code> et Python comprend que c&#8217;est une expression g&eacute;n&eacute;ratrice.
</ol>

<blockquote class=note>
    <p><span class=u>&#x261E;</span>L&#8217;utilisation d&#8217;une expression g&eacute;n&eacute;ratrice &agrave; la place d&#8217;une compr&eacute;hension de liste peut sauver &agrave; la fois <abbr>CPU</abbr> et <abbr>RAM</abbr>. Si vous construisez une liste juste pour la jeter (<i>par exemple</i> en la passant &agrave; <code>tuple()</code> ou <code>set()</code>), utilisez plut&ocirc;t une expression g&eacute;n&eacute;ratrice!
</blockquote>

<p>Voici une autre fa&ccedil;on de faire la m&ecirc;me chose en utilisant une <a href=generators.html>fonction g&eacute;n&eacute;ratrice</a>:

<pre class='nd pp'><code>def ord_map(a_string):
    for c in a_string:
        yield ord(c)

gen = ord_map(unique_characters)</code></pre>

<p>L&#8217;expression g&eacute;n&eacute;ratrice est plus compacte mais fonctionnellement &eacute;quivalente.

<p class=a>&#x2042;

<h2 id=permutations>Le Calcul Des Permutations&hellip; Le Chemin Paresseux!</h2>

<p>Tout d&#8217abord, que diable sont les permutations? Les permutations sont un concept math&eacute;matique. (Il y a en fait plusieurs d&eacute;finitions qui d&eacute;pendent du type de math&eacute;matiques que vous pratiquez. Ici je parle d&#8217;analyse combinatoire, mais si cela ne signifie rien pour vous, ne vous inqui&eacute;tez pas. Comme toujours, <a href=http://fr.wikipedia.org/wiki/Combinatoire>Wikipedia est votre ami</a>.)

<p>L&#8217;id&eacute;e est que vous prenez une liste de choses (pouvant &ecirc;tre des nombres, pouvant &ecirc;tre des lettres, pouvant &ecirc;tre des ours dansant) et trouvez tous les moyens possibles de les scinder en listes plus petites. Toutes les listes plus petites ont la m&ecirc;me taille qui peut &ecirc;tre aussi petite que 1 et aussi grande que le nombre total d&#8217;&eacute;l&eacute;ments. Oh, et rien ne peut &ecirc;tre r&eacute;p&eacute;t&eacute;. Les math&eacute;maticiens disent des choses du genre &#8220;trouvons les permutations de 2 &eacute;l&eacute;ments choisis parmis 3 &eacute;l&eacute;ments distincts,&#8221; ce qui signifie que vous avez un ensemble de 3 &eacute;l&eacute;ments et que vous voulez trouver toutes les paires ordonn&eacute;es possibles.


<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>                              <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>perms = itertools.permutations([1, 2, 3], 2)</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>                                   <span class=u>&#x2462;</span></a>
<samp class=pp>(1, 2)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(1, 3)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<a><samp class=pp>(2, 1)</samp>                                            <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(2, 3)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(3, 1)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(3, 2)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>                                   <span class=u>&#x2464;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp></pre>
<ol>
    <li>Le module <code>itertools</code> est compos&eacute; de toutes sortes de trucs amusants, cela inclue une fonction <code>permutations()</code> qui fait tout le travail difficile pour trouver les permutations.
    <li>La fonction <code>permutations()</code> prend une s&eacute;quence (ici une liste de trois entiers) et un  nombre qui est le nombre d&#8217;&eacute;l&eacute;ments que vous voulez dans chaque groupe plus petit. La fonction retourne un it&eacute;rateur que vous pouvez utiliser dans une boucle <code>for</code> ou tout autre vieille m&eacute;thode d&#8217;it&eacute;ration. Ici je vais parcourir l&#8217; it&eacute;rateur manuellement pour r&eacute;v&eacute;ler toute les valeurs.
    <li>La premi&egrave;re permutation de <code>[1, 2, 3]</code> pris 2 par 2 est <code>(1, 2)</code>.
    <li>Notez que les permutations sont class&eacute;es: <code>(2, 1)</code> est diff&eacute;rente de <code>(1, 2)</code>.
    <li>&Ccedil;a y est! Ce sont toutes les permutations de <code>[1, 2, 3]</code> prises 2 par 2. Les pairs comme <code>(1, 1)</code> et <code>(2, 2)</code> ne se pr&eacute;sentent jamais car elles contiennent des r&eacute;p&eacute;titions et ne sont donc pas des permutations valides. Quand il n'y a plus de permutations, l&#8217;it&eacute;rateur soul&egrave;ve une exception <code>StopIteration</code>.
</ol>

<aside>Le module <code>itertools</code> contient beaucoup de trucs amusants.</aside>

<p>La fonction <code>permutations()</code> n&#8217;a pas &agrave; prendre une liste. Il peut prendre n&#8217;importe quelle séquence&nbsp;&mdash;&nbsp;m&ecirc;me une cha&icirc;ne de caract&egrave;res.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>perms = itertools.permutations('ABC', 3)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<a><samp class=pp>('A', 'B', 'C')</samp>                               <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('A', 'C', 'B')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('B', 'A', 'C')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('B', 'C', 'A')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('C', 'A', 'B')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('C', 'B', 'A')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.permutations('ABC', 3))</kbd>    <span class=u>&#x2462;</span></a>
<samp class=pp>[('A', 'B', 'C'), ('A', 'C', 'B'),
 ('B', 'A', 'C'), ('B', 'C', 'A'),
 ('C', 'A', 'B'), ('C', 'B', 'A')]</samp></pre>
<ol>
<li>Une cha&icirc;ne de caract&egrave;res est juste une s&eacute;quence de caract&egrave;res. La cha&icirc;ne de caract&egrave;res <code>'ABC'</code> est &eacute;quivalente &agrave; la liste <code>['A', 'B', 'C']</code> dans le but de trouver les permutations.
<li>La premi&egrave;re permutation des 3 &eacute;l&eacute;ments <code>['A', 'B', 'C']</code>, pris 3 par 3 est <code>('A', 'B', 'C')</code>. Il y a cinq autres permutations&nbsp;&mdash;&nbsp;les m&ecirc;mes trois caract&egrave;res dans tous les ordres possibles.
<li>Puisque la fonction <code>permutations()</code> retourne toujours un it&eacute;rateur, un moyen facile de d&eacute;boguer des permutations est de passer cet it&eacute;rateur en param&egrave;tre &agrave; la fonction int&eacute;gr&eacute;e <code>list()</code> pour voir toutes les permutations imm&eacute;diatement.
</ol>

<p class=a>&#x2042;

<h2 id=more-itertools>Autre trucs amusants dans le module <code>itertools</code></h2>
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.product('ABC', '123'))</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>[('A', '1'), ('A', '2'), ('A', '3'), 
 ('B', '1'), ('B', '2'), ('B', '3'), 
 ('C', '1'), ('C', '2'), ('C', '3')]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.combinations('ABC', 2))</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>[('A', 'B'), ('A', 'C'), ('B', 'C')]</samp></pre>
<ol>
<li>La fonction <code>itertools.product()</code> retourne un it&eacute;rateur contenant le produit cartesien de deux s&eacute;quences.
<li>La fonction <code>itertools.combinations()</code> retourne un it&eacute;rateur contenant toutes les combinaisons possibles de la s&eacute;quence donn&eacute;e pour une longueur donn&eacute;e. Ceci est identique &agrave; la fonction <code>itertools.permutations()</code>, &agrave; l&#8217;exception des combinaisons n&#8217;incluant pas des &eacute;l&eacute;ments &eacute;tant des doublons d&#8217;autres &eacute;l&eacute;ments rang&eacute;s dans un ordre diff&eacute;rent. Donc <code>itertools.permutations('ABC', 2)</code> retournera &agrave; la fois <code>('A', 'B')</code> et <code>('B', 'A')</code> (entre autres), mais <code>itertools.combinations('ABC', 2)</code> ne retournera pas <code>('B', 'A')</code> car c&#8217;est un doublon de <code>('A', 'B')</code> dans un ordre diff&eacute;rent.
</ol>

<p class=d>[<a href=examples/favorite-people.txt>download <code>favorite-people.txt</code></a>]
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>names = list(open('examples/favorite-people.txt', encoding='utf-8'))</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Dora\n', 'Ethan\n', 'Wesley\n', 'John\n', 'Anne\n',
'Mike\n', 'Chris\n', 'Sarah\n', 'Alex\n', 'Lizzie\n']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = [name.rstrip() for name in names]</kbd>                             <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Dora', 'Ethan', 'Wesley', 'John', 'Anne',
'Mike', 'Chris', 'Sarah', 'Alex', 'Lizzie']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = sorted(names)</kbd>                                                 <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Alex', 'Anne', 'Chris', 'Dora', 'Ethan',
'John', 'Lizzie', 'Mike', 'Sarah', 'Wesley']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = sorted(names, key=len)</kbd>                                        <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Alex', 'Anne', 'Dora', 'John', 'Mike',
'Chris', 'Ethan', 'Sarah', 'Lizzie', 'Wesley']</samp></pre>
<ol>
<li>Cet idiome retourne une liste des lignes siitu&eacute;es dans un fichier texte.
<li>Malheureusement (pour cet exemple), l&#8217;idiome <code>list(open(<var>filename</var>))</code> comprend &eacute;galement les retours chariot &agrave; la fin de chaque ligne. Cette compr&eacute;hension de liste utilise la m&eacute;thode de cha&icirc;nes de caract&egrave;res <code>rstrip()</code> pour les retirer avec les espaces qui tra&icirc;nent &agrave; la fin de chaque ligne. (Les cha&icirc;nes de caract&egrave;res disposent aussi d&#8217;une m&eacute;thode <code>lstrip()</code> pour enlever les espaces situ&eacute;s en d&eacute;but de cha&icirc;ne de caract&egrave;res et une m&eacute;thode <code>strip()</code> qui enl&egrave;vent les deux.)
<li>La fonction <code>sorted()</code> prend une liste et la retourne tri&eacute;e. Elle trie alphab&eacute;tiquement par d&eacute;faut.
<li>Mais la fonction <code>sorted()</code> peut aussi prendre une fonction avec le param&egrave;tre <var>key</var> et elle fera son tri en fonction de cette clef. Dans ce cas, la fonction de tri est <code>len()</code>, le tri est donc organis&eacute; en fonction de <code>len(<var>chaque &eacute;l&eacute;ment</var>)</code>. Le nom le plus petit vient en premier, puis un plus long et en dernier le plus long.
</ol>

<p>Qu&#8217;est-ce que cela a &agrave; voir avec le module <code>itertools</code>? Je suis content que vous vous posiez la question.

<pre class=screen>
&hellip;continuing from the previous interactive shell&hellip;
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>groups = itertools.groupby(names, len)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>groups</kbd>
<samp class=pp>&lt;itertools.groupby object at 0x00BB20C0></samp>
<samp class=p>>>> </samp><kbd class=pp>list(groups)</kbd>
<samp class=pp>[(4, &lt;itertools._grouper object at 0x00BA8BF0>),
 (5, &lt;itertools._grouper object at 0x00BB4050>),
 (6, &lt;itertools._grouper object at 0x00BB4030>)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>groups = itertools.groupby(names, len)</kbd>   <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>for name_length, name_iter in groups:</kbd>    <span class=u>&#x2462;</span></a>
<samp class=p>... </samp><kbd class=pp>    print('Names with {0:d} letters:'.format(name_length))</kbd>
<samp class=p>... </samp><kbd class=pp>    for name in name_iter:</kbd>
<samp class=p>... </samp><kbd class=pp>        print(name)</kbd>
<samp class=p>... </samp>
<samp>Names with 4 letters:
Alex
Anne
Dora
John
Mike
Names with 5 letters:
Chris
Ethan
Sarah
Names with 6 letters:
Lizzie
Wesley</samp></pre>
<ol>
<li>La fonction <code>itertools.groupby()</code> prend une s&eacute;quence et une fonction clef et retourne un it&eacute;rateur qui g&eacute;n&egrave;re des pairs. Chaque pair contient le r&eacute;sultat de <code>key_function(<var>chaque &eacute;l&eacute;ment</var>)</code> et un autre it&eacute;rateur contenant tous les &eacute;l&eacute;ments qui partagent ce r&eacute;sultat de clef.
<li>L&#8217;appel de la fonction <code>list()</code> a &#8220;&eacute;puis&eacute;&#8221; l&#8217;it&eacute;rateur, <i>par exemple:</i> vous avez d&eacute;j&agrave; g&eacute;n&eacute;r&eacute; chaque &eacute;l&eacute;ment contenu par l&#8217;it&eacute;rateur pour construire la liste. Il n&#8217;y a pas de bouton &#8220;reset&#8221; sur un it&eacute;rateur; vous ne pouvez pas juste recommencer une fois que vous l&#8217;avez &eacute;puis&eacute;. Si vous voulez refaire un boucle dans celui-ci (par exemple dans la prochaine boucle <code>for</code>), vous devez appel&eacute; &agrave; nouveau <code>itertools.groupby()</code> afin de cr&eacute;er un nouvel it&eacute;rateur.
<li>Dans cet exemple, &eacute;tant donn&eacute; une liste de noms <em>d&eacute;j&agrave; tri&eacute;s par longueur</em>, <code>itertools.groupby(names, len)</code> mettra tous les noms de 4 lettres dans un it&eacute;rateur, tous les noms de 5 lettres dans un autre it&eacute;rateur, et ainsi de suite. La fonction <code>groupby()</code> est compl&egrave;tement g&eacute;n&eacute;rique; elle pourrait regrouper les cha&icirc;nes de caract&egrave;res en fonction de la premi&egrave;re lettre, les compter en fonction de leur nombre d&#8217occurences, ou de toute autre fonction clef &agrave; laquelle vous pouvez penser.
</ol>
<!-- YO DAWG, WE HEARD YOU LIKE LOOPING, SO WE PUT AN ITERATOR IN YOUR ITERATOR SO YOU CAN LOOP WHILE YOU LOOP. -->

<blockquote class=note>
    <p><span class=u>&#x261E;</span>La fonction <code>itertools.groupby()</code> ne fonctionne seulement que si la s&eacute;quence d&#8217;entr&eacute;e est d&eacute;j&agrave; tri&eacute;e par la fonction de groupement. Dans l&#8217;exemple ci-dessus vous avez regoup&eacute; une liste de noms via la fonction <code>len()</code>. Cela a march&eacute; seulement parce que la liste d&#8217;entr&eacute;e &eacute;tait d&eacute;j&agrave; tri&eacute;e par longueur.
</blockquote>

<p>Regardez-vous de pr&egrave;s?
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>list(range(0, 3))</kbd>
<samp class=pp>[0, 1, 2]</samp>
<samp class=p>>>> </samp><kbd class=pp>list(range(10, 13))</kbd>
<samp class=pp>[10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.chain(range(0, 3), range(10, 13)))</kbd>        <span class=u>&#x2460;</span></a>
<samp class=pp>[0, 1, 2, 10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(zip(range(0, 3), range(10, 13)))</kbd>                    <span class=u>&#x2461;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(zip(range(0, 3), range(10, 14)))</kbd>                    <span class=u>&#x2462;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.zip_longest(range(0, 3), range(10, 14)))</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12), (None, 13)]</samp></pre>
<ol>
<li>La fonction <code>itertools.chain()</code> prend deux it&eacute;rateurs et retourne un it&eacute;rateur qui contient tous les &eacute;l&eacute;ments du premier it&eacute;rateur suivis par tous les &eacute;l&eacute;ments du second it&eacute;rateur. (En fait, elle peut prendre n&#8217;importe quel nombre d&#8217;it&eacute;rateurs et elle les cha&icirc;ne dans l&#8217;ordre dans lequel ils ont &eacute;t&eacute; pass&eacute;s &agrave; la fonction.)
<li>La fonction <code>zip()</code> fait quelque chose de prosa&iuml;que qui se r&eacute;v&egrave;le &ecirc;tre extr&ecirc;mement utile: elle prend n&#8217;importe quel nombre de s&eacute;quences et retourne un it&eacute;rateur qui retourne des tuples des premiers &eacute;l&eacute;ments de chaque s&eacute;quence, puis des seconds &eacute;l&eacute;ments de chacun d&#8217;entre eux, puis des troisi&egrave;mes et ainsi de suite.
<li>La fonction <code>zip()</code> s&#8217;arr&ecirc;te &agrave; la fin de la s&eacute;quence la plus courte. <code>range(10, 14)</code> contient 4 &eacute;l&eacute;ments (10, 11, 12, et 13) mais <code>range(0, 3)</code> seulement 3, par cons&eacute;quent la fonction <code>zip()</code> retourne un it&eacute;rateur de 3 &eacute;l&eacute;ments.
<li>Par ailleurs, la fonction <code>itertools.zip_longest()</code> s&#8217;arr&ecirc;te &agrave; la fin de la s&eacute;quence <em>la plus longue</em>, ins&eacute;rant des valeurs <code>None</code> pour les &eacute;l&eacute;ments une fois pass&eacute; la fin de la s&eacute;quence la plus courte.
</ol>

<p id=dict-zip>OK, tout cela &eacute;tait tr&egrave;s int&eacute;ressant mais comment cela interagit-il avec le solveur alpham&eacute;tique? Voici comment:

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>characters = ('S', 'M', 'E', 'D', 'O', 'N', 'R', 'Y')</kbd>
<samp class=p>>>> </samp><kbd class=pp>guess = ('1', '2', '0', '3', '4', '5', '6', '7')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>tuple(zip(characters, guess))</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>(('S', '1'), ('M', '2'), ('E', '0'), ('D', '3'),
 ('O', '4'), ('N', '5'), ('R', '6'), ('Y', '7'))</samp>
<a><samp class=p>>>> </samp><kbd class=pp>dict(zip(characters, guess))</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>{'E': '0', 'D': '3', 'M': '2', 'O': '4',
 'N': '5', 'S': '1', 'R': '6', 'Y': '7'}</samp></pre>
<ol>
<li>&Eacute;tant donn&eacute; une liste de lettres et une liste de chiffres (chacun repr&eacute;sent&eacute;s ici par une cha&icirc;ne de 1-caract&egrave;re), la fonction <code>zip</code> va cr&eacute;er des paires de lettres et de chiffres en respectant leur ordre initial.
<li>Pourquoi est-ce cool? Parce que cette structure de donn&eacute;es se trouve &ecirc;tre exactement la bonne structure &agrave; passer &agrave; la fonction <code>dict()</code> pour cr&eacute;er un dictionnaire qui utilise des lettres comme clefs et leur nombres associ&eacute;s comme valeurs. (Ce n&#8217;est pas la seule fa&ccedil;on de le faire, bien s&ucirc;r. Vous pouvez utiliser une <a href=comprehensions.html#dictionarycomprehension>compr&eacute;hension de dictionnaire</a> pour cr&eacute;er directement un dictionnaire.) Bien que la repr&eacute;sentation imprim&eacute;e du dictionnaire liste les paires dans un ordre diff&eacute;rent (les dictionnaires n&#8217;ont pas d&#8217;&#8220;ordre&#8221; en soi), vous pouvez voir que chaque lettre est associ&eacute;e &agrave; son chiffre, en fonction de l&#8217;agencement des s&eacute;quences initiales de <var>characters</var> et de <var>guess</var>.
</ol>

<p id=guess>Le solveur alpham&eacute;tique utilise cette technique pour cr&eacute;er un dictionnaire qui transpose les lettres du puzzle en chiffres dans la solution, pour chaque solution possible.

<pre class='nd pp'><code>characters = tuple(ord(c) for c in sorted_characters)
digits = tuple(ord(c) for c in '0123456789')
...
for guess in itertools.permutations(digits, len(characters)):
    ...
<mark>    equation = puzzle.translate(dict(zip(characters, guess)))</mark></code></pre>

<p>Mais quelle est cette m&eacute;thode <code>translate()</code>? Ah, maintenant vous attaquez la partie <em>vraiment</em> fun.

<p class=a>&#x2042;

<h2 id=string-translate>A New Kind Of String Manipulation</h2>

<p>Python strings have many methods. You learned about some of those methods in <a href=strings.html>the Strings chapter</a>: <code>lower()</code>, <code>count()</code>, and <code>format()</code>. Now I want to introduce you to a powerful but little-known string manipulation technique: the <code>translate()</code> method.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table = {ord('A'): ord('O')}</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table</kbd>                         <span class=u>&#x2461;</span></a>
<samp class=pp>{65: 79}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'MARK'.translate(translation_table)</kbd>       <span class=u>&#x2462;</span></a>
<samp class=pp>'MORK'</samp></pre>
<ol>
<li>String translation starts with a translation table, which is just a dictionary that maps one character to another. Actually, &#8220;character&#8221; is incorrect&nbsp;&mdash;&nbsp;the translation table really maps one <em>byte</em> to another.
<li>Remember, bytes in Python 3 are integers. The <code>ord()</code> function returns the <abbr>ASCII</abbr> value of a character, which, in the case of A&ndash;Z, is always a byte from 65 to 90.
<li>The <code>translate()</code> method on a string takes a translation table and runs the string through it. That is, it replaces all occurrences of the keys of the translation table with the corresponding values. In this case, &#8220;translating&#8221; <code>MARK</code> to <code>MORK</code>.
</ol>

<aside>Now you&#8217;re getting to the <em>really</em> fun part.</aside>

<p>What does this have to do with solving alphametic puzzles? As it turns out, everything.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>characters = tuple(ord(c) for c in 'SMEDONRY')</kbd>       <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>characters</kbd>
<samp class=pp>(83, 77, 69, 68, 79, 78, 82, 89)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>guess = tuple(ord(c) for c in '91570682')</kbd>            <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>guess</kbd>
<samp class=pp>(57, 49, 53, 55, 48, 54, 56, 50)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table = dict(zip(characters, guess))</kbd>     <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>translation_table</kbd>
<samp class=pp>{68: 55, 69: 53, 77: 49, 78: 54, 79: 48, 82: 56, 83: 57, 89: 50}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'SEND + MORE == MONEY'.translate(translation_table)</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'9567 + 1085 == 10652'</samp></pre>
<ol>
<li>Using a <a href=#generator-expressions>generator expression</a>, we quickly compute the byte values for each character in a string. <var>characters</var> is an example of the value of <var>sorted_characters</var> in the <code>alphametics.solve()</code> function.
<li>Using another generator expression, we quickly compute the byte values for each digit in this string. The result, <var>guess</var>, is of the form <a href=#guess>returned by the <code>itertools.permutations()</code> function</a> in the <code>alphametics.solve()</code> function.
<li>This translation table is generated by <a href=#dict-zip>zipping <var>characters</var> and <var>guess</var> together</a> and building a dictionary from the resulting sequence of pairs. This is exactly what the <code>alphametics.solve()</code> function does inside the <code>for</code> loop.
<li>Finally, we pass this translation table to the <code>translate()</code> method of the original puzzle string. This converts each letter in the string to the corresponding digit (based on the letters in <var>characters</var> and the digits in <var>guess</var>). The result is a valid Python expression, as a string.
</ol>

<p>That&#8217;s pretty impressive. But what can you do with a string that happens to be a valid Python expression?

<p class=a>&#x2042;

<h2 id=eval>Evaluating Arbitrary Strings As Python Expressions</h2>

<p>This is the final piece of the puzzle (or rather, the final piece of the puzzle solver). After all that fancy string manipulation, we&#8217;re left with a string like <code>'9567 + 1085 == 10652'</code>. But that&#8217;s a string, and what good is a string? Enter <code>eval()</code>, the universal Python evaluation tool.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>eval('1 + 1 == 2')</kbd>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('1 + 1 == 3')</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('9567 + 1085 == 10652')</kbd>
<samp class=pp>True</samp></pre>

<p>But wait, there&#8217;s more! The <code>eval()</code> function isn&#8217;t limited to boolean expressions. It can handle <em>any</em> Python expression and returns <em>any</em> datatype.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>eval('"A" + "B"')</kbd>
<samp class=pp>'AB'</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('"MARK".translate({65: 79})')</kbd>
<samp class=pp>'MORK'</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('"AAAAA".count("A")')</kbd>
<samp class=pp>5</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('["*"] * 5')</kbd>
<samp class=pp>['*', '*', '*', '*', '*']</samp></pre>

<p>But wait, that&#8217;s not all!

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5")</kbd>         <span class=u>&#x2460;</span></a>
<samp class=pp>25</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("pow(x, 2)")</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>25</samp>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("math.sqrt(x)")</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>2.2360679774997898</samp></pre>
<ol>
<li>The expression that <code>eval()</code> takes can reference global variables defined outside the <code>eval()</code>. If called within a function, it can reference local variables too.
<li>And functions.
<li>And modules.
</ol>

<p>Hey, wait a minute&hellip;

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import subprocess</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("subprocess.getoutput('ls ~')")</kbd>                  <span class=u>&#x2460;</span></a>
<samp class=pp>'Desktop         Library         Pictures \
 Documents       Movies          Public   \
 Music           Sites'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("subprocess.getoutput('rm /some/random/file')")</kbd>  <span class=u>&#x2461;</span></a></pre>
<ol>
<li>The <code>subprocess</code> module allows you to run arbitrary shell commands and get the result as a Python string.
<li>Arbitrary shell commands can have permanent consequences.
</ol>

<p>It&#8217;s even worse than that, because there&#8217;s a global <code>__import__()</code> function that takes a module name as a string, imports the module, and returns a reference to it. Combined with the power of <code>eval()</code>, you can construct a single expression that will wipe out all your files:

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm /some/random/file')")</kbd>  <span class=u>&#x2460;</span></a></pre>
<ol>
<li>Now imagine the output of <code>'rm -rf ~'</code>. Actually there wouldn&#8217;t be any output, but you wouldn&#8217;t have any files left either.
</ol>

<p class=xxxl>eval() is EVIL

<p>Well, the evil part is evaluating arbitrary expressions from untrusted sources. You should only use <code>eval()</code> on trusted input. Of course, the trick is figuring out what&#8217;s &#8220;trusted.&#8221; But here&#8217;s something I know for certain: you should <b>NOT</b> take this alphametics solver and put it on the internet as a fun little web service. Don&#8217;t make the mistake of thinking, &#8220;Gosh, the function does a lot of string manipulation before getting a string to evaluate; <em>I can&#8217;t imagine</em> how someone could exploit that.&#8221; Someone <b>WILL</b> figure out how to sneak nasty executable code past all that string manipulation (<a href=http://www.securityfocus.com/blogs/746>stranger things have happened</a>), and then you can kiss your server goodbye.

<p>But surely there&#8217;s <em>some</em> way to evaluate expressions safely? To put <code>eval()</code> in a sandbox where it can&#8217;t access or harm the outside world? Well, yes and no.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5", {}, {})</kbd>               <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'x' is not defined</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5", {"x": x}, {})</kbd>         <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("math.sqrt(x)", {"x": x}, {})</kbd>  <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'math' is not defined</samp></pre>
<ol>
<li>The second and third parameters passed to the <code>eval()</code> function act as the global and local namespaces for evaluating the expression. In this case, they are both empty, which means that when the string <code>"x * 5"</code> is evaluated, there is no reference to <var>x</var> in either the global or local namespace, so <code>eval()</code> throws an exception.
<li>You can selectively include specific values in the global namespace by listing them individually. Then those&nbsp;&mdash;&nbsp;and only those&nbsp;&mdash;&nbsp;variables will be available during evaluation.
<li>Even though you just imported the <code>math</code> module, you didn&#8217;t include it in the namespace passed to the <code>eval()</code> function, so the evaluation failed.
</ol>

<p>Gee, that was easy. Lemme make an alphametics web service now!

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>eval("pow(5, 2)", {}, {})</kbd>                   <span class=u>&#x2460;</span></a>
<samp class=pp>25</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("__import__('math').sqrt(5)", {}, {})</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>2.2360679774997898</samp></pre>
<ol>
<li>Even though you&#8217;ve passed empty dictionaries for the global and local namespaces, all of Python&#8217;s built-in functions are still available during evaluation. So <code>pow(5, 2)</code> works, because <code>5</code> and <code>2</code> are literals, and <code>pow()</code> is a built-in function.
<li>Unfortunately (and if you don&#8217;t see why it&#8217;s unfortunate, read on), the <code>__import__()</code> function is also a built-in function, so it works too.
</ol>

<p>Yeah, that means you can still do nasty things, even if you explicitly set the global and local namespaces to empty dictionaries when calling <code>eval()</code>:

<pre class='nd screen'><samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm /some/random/file')", {}, {})</kbd></pre>

<p>Oops. I&#8217;m glad I didn&#8217;t make that alphametics web service. Is there <em>any</em> way to use <code>eval()</code> safely? Well, yes and no.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>eval("__import__('math').sqrt(5)",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name '__import__' is not defined</samp>
<samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm -rf /')",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name '__import__' is not defined</samp></pre>
<ol>
<li>To evaluate untrusted expressions safely, you need to define a global namespace dictionary that maps <code>"__builtins__"</code> to <code>None</code>, the Python null value. Internally, the &#8220;built-in&#8221; functions are contained within a pseudo-module called <code>"__builtins__"</code>. This pseudo-module (<i>i.e.</i> the set of built-in functions) is made available to evaluated expressions unless you explicitly override it.
<li>Be sure you&#8217;ve overridden <code>__builtins__</code>. Not <code>__builtin__</code>, <code>__built-ins__</code>, or some other variation that will work just fine but expose you to catastrophic risks.
</ol>

<p>So <code>eval()</code> is safe now? Well, yes and no.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>eval("2 ** 2147483647",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2460;</span></a>
</pre>
<ol>
<li>Even without access to <code>__builtins__</code>, you can still launch a denial-of-service attack. For example, trying to raise <code>2</code> to the <code>2147483647</code><sup>th</sup> power will spike your server&#8217;s <abbr>CPU</abbr> utilization to 100% for quite some time. (If you&#8217;re trying this in the interactive shell, press <kbd>Ctrl-C</kbd> a few times to break out of it.) Technically this expression <em>will</em> return a value eventually, but in the meantime your server will be doing a whole lot of nothing.
</ol>

<p>In the end, it <em>is</em> possible to safely evaluate untrusted Python expressions, for some definition of &#8220;safe&#8221; that turns out not to be terribly useful in real life. It&#8217;s fine if you&#8217;re just playing around, and it&#8217;s fine if you only ever pass it trusted input. But anything else is just asking for trouble.

<p class=a>&#x2042;

<h2 id=alphametics-finale>Putting It All Together</h2>

<p>To recap: this program solves alphametic puzzles by brute force, <i>i.e.</i> through an exhaustive search of all possible solutions. To do this, it&hellip;

<ol>
<li><a href=#re-findall>Finds all the letters in the puzzle</a> with the <code>re.findall()</code> function
<li><a href=#unique-items>Find all the <em>unique</em> letters in the puzzle</a> with sets and the <code>set()</code> function
<li><a href=#assert>Checks if there are more than 10 unique letters</a> (meaning the puzzle is definitely unsolvable) with an <code>assert</code> statement
<li><a href=#generator-objects>Converts the letters to their ASCII equivalents</a> with a generator object
<li><a href=#permutations>Calculates all the possible solutions</a> with the <code>itertools.permutations()</code> function
<li><a href=#string-translate>Converts each possible solution to a Python expression</a> with the <code>translate()</code> string method
<li><a href=#eval>Tests each possible solution by evaluating the Python expression</a> with the <code>eval()</code> function
<li>Returns the first solution that evaluates to <code>True</code>
</ol>

<p>&hellip;in just 14 lines of code.

<p class=a>&#x2042;

<h2 id=furtherreading>Further Reading</h2>

<ul>
<li><a href=http://docs.python.org/3.1/library/itertools.html><code>itertools</code> module</a>
<li><a href=http://www.doughellmann.com/PyMOTW/itertools/><code>itertools</code>&nbsp;&mdash;&nbsp;Iterator functions for efficient looping</a>
<li><a href=http://blip.tv/file/1947373/>Watch Raymond Hettinger&#8217;s &#8220;Easy AI with Python&#8221; talk</a> at PyCon 2009
<li><a href=http://code.activestate.com/recipes/576615/>Recipe 576615: Alphametics solver</a>, Raymond Hettinger&#8217;s original alphametics solver for Python 2
<li><a href=http://code.activestate.com/recipes/users/178123/>More of Raymond Hettinger&#8217;s recipes</a> in the ActiveState Code repository
<li><a href=http://en.wikipedia.org/wiki/Verbal_arithmetic>Alphametics on Wikipedia</a>
<li><a href=http://www.tkcs-collins.com/truman/alphamet/index.shtml>Alphametics Index</a>, including <a href=http://www.tkcs-collins.com/truman/alphamet/alphamet.shtml>lots of puzzles</a> and <a href=http://www.tkcs-collins.com/truman/alphamet/alpha_gen.shtml>a generator to make your own</a>
</ul>

<p>Many thanks to Raymond Hettinger for agreeing to relicense his code so I could port it to Python 3 and use it as the basis for this chapter.

<p class=v><a href=iterators.html rel=prev title='back to &#8220;Classes &amp; Iterators&#8221;'><span class=u>&#x261C;</span></a> <a href=unit-testing.html rel=next title='onward to &#8220;Unit Testing&#8221;'><span class=u>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;10 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
