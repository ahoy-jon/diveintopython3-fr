<!DOCTYPE html>
<meta charset=utf-8>
<title>Expressions r&eacute;guli&egrave;res - Plongez au c&oelig;ur de Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 5}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="propuls&eacute; par Google&trade;">&nbsp;<input type=submit name=root value=Recherche></div></form>
<p>Vous &ecirc;tes ici: <a href=index.html>Accueil</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#regular-expressions>Plongez au c&oelig;ur de Python 3</a> <span class=u>&#8227;</span>
<p id=level>Niveau de difficult&eacute;: <span class=u title=intermediate>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Expressions R&eacute;guli&egrave;res</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Certaines personnes, quand elles sont confront&eacute;es &agrave; un probl&egrave;me, pensent &#8220;Je sais, je vais utiliser les expressions r&eacute;guli&egrave;res&#8221;. Maintenant, elles ont deux probl&egrave;mes. <span class=u>&#x275E;</span><br>&mdash; <a href=http://www.jwz.org/hacks/marginal.html>Jamie Zawinski</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Lan&ccedil;ons nous</h2>
<p class=f>Extraire une petite partie de texte hors d'un immense bloc de texte est un d&eacute;fi. En Python, les cha&icirc;nes de caract&egrave;res poss&egrave;dent des m&eacute;thodes pour chercher et remplacer : <code>index()</code>, <code>find()</code>, <code>split()</code>, <code>count()</code>, <code>replace()</code>, <i class=baa>&amp;</i>c. Cependant
    ces m&eacute;thodes sont limit&eacute;es aux cas les plus simples. Par exemple, la m&eacute;thode <code>index()</code> cherche une sous-cha&icirc;ne simple, cod&eacute;e en dur, et la recherche est toujours sensible &agrave; la casse. Pour effectuer des recherches insensibles &agrave; la casse d'une cha&icirc;ne de charact&egrave;re <var>s</var>, vous devez appeller la m&eacute;thode <code>s.lower()</code> ou <code>s.upper()</code> et &ecirc;tre sur que la cha&icirc;ne recherch&eacute;e est appropri&eacute;e &agrave; la casse de celle &agrave; &eacute;galer. Les m&eacute;thodes <code>replace()</code> et <code>split()</code> ont les m&ecirc;mes limitations.
<p>Si votre objectif peut &ecirc;tre accomplit avec les m&eacute;thodes li&eacute;es aux cha&icirc;nes, vous devriez les utiliser. Elles sont rapides, simples et facile &agrave; utiliser, et il y a beacoup de chose &agrave; dire sur du code rapide, simple et lisible. Mais si vous vous trouvez &agrave; utiliser beaucoup de diff&eacute;rentes fonctions de cha&icirc;nes de caract&egrave;s avec des instructions <code>if</code> pour traiter les cas sp&eacute;ciaux, ou si vous encha&icirc;nez les appels comme <code>split()</code> et <code>join()</code> afin de d&eacute;couper et de jouer avec vos cha&icirc;nes de caract&egrave;s, alors vous devriez vous mettre aux expressions r&eacute;guli&egrave;res.
<p>Les expressions r&eacute;guli&egrave;res sont un moyen de recherche puissant et (g&eacute;n&eacute;ralement) standardis&eacute;. Bien que les expressions r&eacute;guli&egrave;res soient rigoureuses et diff&eacute;rentes du code classique, le r&eacute;sultat peut finalement &ecirc;tre <em>plus</em> lisible qu'une solution fa&icirc;te-main qui utilise une immense cha&icirc;ne de fonctions li&eacute;es aux cha&icirc;nes de caract&egrave;res. Il y a m&ecirc;me des moyens de garnir de commentaires &agrave; l&#8217;int&egrave;rieur des expressions r&eacute;guli&egrave;res, permettant ainsi d'inclure une documentation d&eacute;taill&eacute;e &agrave; l&#8217;int&eacute;rieur de celles-ci.
<blockquote class='note compare perl5'>
    <p><span class=u>&#x261E;</span>Si vous avez utilis&eacute; les expressions r&eacute;guli&egrave;res dans d&#8217;autres langages (comme Perl, JavaScript, ou PHP), la syntaxe Python vous sera tr&egrave;s famili&egrave;re. Lisez le sommaire du <a href=http://docs.python.org/dev/library/re.html#module-contents>module <code>re</code></a> pour obtenir une vue d'ensemble des fonctions disponibles et de leurs arguments.
</blockquote>
<p class=a>&#x2042;

<h2 id=streetaddresses>&Eacute;tude de cas: Adresses de rues</h2>
<p>Ces s&eacute;ries d&#8217;exemples sont inspir&eacute;es par un probl&egrave;me de la vraie vie que j&#8217;ai rencontr&eacute; dans mon travail quotidien il y a quelques ann&eacute;es de cela, alors que j&#8217;eus besoin de briquer et de standardiser des adresses de rues export&eacute;es d'un syst&egrave;me re&ccedil;u en h&eacute;ritage avant de les importer dans un nouveau syst&egrave;me. (Regardez, je n&#8217;ai pas juste maquill&eacute; cette mati&egrave;re; elle est maintenant fonctionnelle.)  Cette exemple montre de quelle mani&egrave;re j'ai approch&eacute; le probl&egrave;me.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>s = '100 NORTH MAIN ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.replace('ROAD', 'RD.')</kbd>                <span class=u>&#x2460;</span></a>
<samp class=pp>'100 NORTH MAIN RD.'</samp>
<samp class=p>>>> </samp><kbd class=pp>s = '100 NORTH BROAD ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.replace('ROAD', 'RD.')</kbd>                <span class=u>&#x2461;</span></a>
<samp class=pp>'100 NORTH BRD. RD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s[:-4] + s[-4:].replace('ROAD', 'RD.')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>'100 NORTH BROAD RD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>import re</kbd>                               <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('ROAD$', 'RD.', s)</kbd>               <span class=u>&#x2464;</span></a>
<samp class=pp>'100 NORTH BROAD RD.'</samp></pre>
<ol>
    <li>Mon but est de standardiser une adresse de rue de sorte que <code>'ROAD'</code> est toujours abr&eacute;g&eacute; en <code>'RD.'</code>. Au premier coup d&#8217;&oelig;il, je pensais que cela serait suffisamment simple pour que je puisse juste utiliser la m&eacute;thode des cha&icirc;nes de caract&egrave;res <code>replace()</code>. Apr&egrave;s tout, toutes les donn&eacute;es &eacute;taient d&eacute;j&agrave; en majuscules, ainsi les cas en inad&eacute;quations n&#8217;auraient pas &eacute;t&eacute; un probl&egrave;me. Et la cha&icirc;ne de caract&egrave;re recherch&eacute;e, <code>'ROAD'</code>, &eacute;tait une constante. Et dans ce cas trompeusement simple, <code>s.replace()</code> fonctionne en effet.
    <li>La vie, malheureusement, est pleine de contre-exemples, et j&#8217;ai rapidement d&eacute;couvert celui-ci.  Le probl&egrave;me ici est que <code>'ROAD'</code> appara&icirc;t deux foid dans l'adresse, d&#8217;une part dans le nom propre de la rue <code>'BROAD'</code> et d&#8217;autre part en tant que mot propre. La m&eacute;thode <code>replace()</code> voit les deux occurrences et remplace aveugl&eacute;ment chacune des deux; pendant ce temps, je vois mes adresses se d&eacute;truire.
    <li>Pour r&eacute;soudre le probl&egrave;me des adresses avec plus qu'une sous-cha&icirc;ne <code>'ROAD'</code>, vous pouvez recourir &agrave; quelque chose de ce type: chercher et remplacer <code>'ROAD'</code> dans les quatres derniers caract&egrave;res de l&#8217;adresse (<code>s[-4:]</code>), et laisser la cha&icirc;ne de caract&egrave;re seule (<code>s[:-4]</code>). Mais vous constaterez que &ccedil;a commence d&eacute;j&agrave; &agrave; devenir difficile &agrave; manier. Par exemple, le pattern est d&eacute;pendant de la longueur de la cha&icirc;ne que vous remplacez. (Si vous &eacute;tiez en train de remplacer <code>'STREET'</code> avec <code>'ST.'</code>, vous auriez d&ucirc; utiliser <code>s[:-6]</code> et <code>s[-6:].replace(...)</code>.) Voudriez vous revenir dans six mois et d&eacute;boguer ceci? Je sais que moi non.
    <li>Il est temps de passer aux expressions r&eacute;guli&egrave;res. En Python, toutes les fonctionnalit&eacute;s li&eacute;es aux expressions r&eacute;guli&egrave;res sont contenues dans le module <code>re</code>.
    <li>Jeter un coup d&#8217;&oelig;il au premier param&egrave;tre: <code>'ROAD$'</code>. Il s&#8217;agit d'une simple expression r&eacute;guli&egrave;re qui ne correspond &agrave; <code>'ROAD'</code> seulement que quand elle appara&icirc;t &agrave; la fin d&#8217;une cha&icirc;ne de caract&egrave;res. Le symbole <code>$</code> signifie &#8220;fin de la cha&icirc;ne.&#8221; (Il y a un caract&egrave;re correspondant, l&#8217;accent circonflexe <code>^</code>, qui signifie Â«d&eacute;but de la cha&icirc;ne.") Utilisant la fonction <code>re.sub()</code>, vous cherchez l&#8217;expression r&eacute;guli&egrave;re <code>'ROAD$'</code> dans la cha&icirc;ne <var>s</var>  pour la remplacer par <code>'RD.'</code>. Ce qui correspond &agrave; <code>ROAD</code> &agrave; la fin de la cha&icirc;ne <var>s</var>, mais qui ne correspond <em>pas</em> &agrave; <code>ROAD</code> en tant que partie du mot <code>BROAD</code>, car situ&eacute; au milieu de <var>s</var>.
</ol>
<aside>^ correspond au d&eacute;but d&#8217;une cha&icirc;ne. $ correspond &agrave; la fin d&#8217;une cha&icirc;ne.</aside>
<p>En continuant avec mon histoire de nettoyage d&#8217;adresses, j&#8217;ai vite d&eacute;couvert que l&#8217;exemple pr&eacute;c&eacute;dent, correspondant &agrave; <code>'ROAD'</code> &agrave; la fin de l&#8217;adresse, n&#8217;&eacute;tait pas assez bon, parceque toutes les adresses n'incluaient pas du tout une d&eacute;signation de rue. Certaines adresses se terminaient simplement par le nom de la rue. Je n&#8217;en ai pas tenu compte la plupart du temps, mais si le nom de la rue &eacute;tait <code>'BROAD'</code>, alors l&#8217;expression r&eacute;guli&egrave;re reconnaissait  <code>'ROAD'</code> dans une partie de la fin de la cha&icirc;ne du mot <code>'BROAD'</code>, ce qui n'est pas ce que je voulais.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>s = '100 BROAD'</kbd>
<samp class=p>>>> </samp><kbd class=pp>re.sub('ROAD$', 'RD.', s)</kbd>
<samp class=pp>'100 BRD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('\\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>'100 BROAD'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>'100 BROAD'</samp>
<samp class=p>>>> </samp><kbd class=pp>s = '100 BROAD ROAD APT. 3'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2462;</span></a>
<samp class=pp>'100 BROAD ROAD APT. 3'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD\b', 'RD.', s)</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'100 BROAD RD. APT 3'</samp></pre>
<ol>
<li>Ce que je voulait <em>vraiment</em> &eacute;tait de reconna&icirc;tre <code>'ROAD'</code> quand il se situait en fin de cha&icirc;ne <em>et</em> quand il &eacute;tait un mot entier (et non une partie d&#8217;un mot plus grand). Pour exprimer ceci &agrave; travers un expression r&eacute;guli&egrave;re, vous utlisez <code>\b</code>, ce qui signifie &#8220;une limite de mot doit maintenant appara&icirc;tre a n&ocirc;tre droite.&#8221; En Python, ceci est compliqu&eacute; par le fait que le caract&egrave;re <code>'\'</code> dans une cha&icirc;ne doit lui-m&ecirc;me &ecirc;tre &eacute;chapp&eacute;. Ceci est parfois appel&eacute; la plaie du backslash, et c&#8217;est une raison pour laquelle les expressions r&eacute;guli&egrave;res sont plus faciles en Perl qu&#8217;en Python. C&ocirc;t&eacute; inconv&eacute;nients, Perl m&eacute;lange les expressions r&eacute;guli&egrave;res avec d&#8217;autres syntaxes, donc si vous avez un bug, il peut &ecirc;tre difficile de dire si c'est un bogue dans la syntaxe ou un bogue dans l&#8217;expression r&eacute;guli&egrave;re.
<li>Pour contourner la plaie du backslash, vous pouvez utiliser ce qu'on appelle une <i>cha&icirc;ne brute</i>, en pr&eacute;fixant la cha&icirc;ne par la lettre <code>r</code>. Cela signale &agrave; Python que rien dans cette cha&icirc;ne ne doit &ecirc;tre &eacute;chapp&eacute;; <code>'\t'</code> est un caract&egrave;re de tabulation, mais <code>r'\t'</code> repr&eacute;sente vraiment le caract&egrave;re backslash <code>\</code> suivi de la lettre <code>t</code>. Je recommande toujours l&#8217;utilisation de cha&icirc;nes brutes lorsque vous traitez avec des expressions r&eacute;guli&egrave;res, sans quoi, les choses deviennent trop confuses et trop vite (de plus les expressions r&eacute;guli&egrave;res sont d&eacute;j&agrave; suffisamment confuses comme &ccedil;a).
<li><em>*soupir*</em>  Malheureusement, j&#8217;ai vite trouv&eacute; plusieurs cas qui contredisaient ma logique. Dans ce cas-ci, l'adresse de rue contenait le mot <code>'ROAD'</code> en tant que mot entier de lui-m&ecirc;me, mais ce n&#8217;&eacute;tait pas termin&eacute;, en effet l'adresse avait un num&eacute;ro d&#8217;appartement apr&egrave;s la d&eacute;signation de la rue. Parceque <code>'ROAD'</code> n&#8217;est pas la toute fin de la cha&icirc;ne, cela ne correspond pas, par cons&eacute;quent l&#8217;appelle entier &agrave; <code>re.sub()</code> finit par ne plus remplacer quoi que ce soit, et vous obtenez le retour de la cha&icirc;ne d&#8217;origine, ce qui n&#8217;est pas ce que vous voulez.
<li>Pour r&eacute;soudre ce probl&egrave;me, J&#8217;ai supprim&eacute; le caract&egrave;re <code>$</code> et ajout&eacute; un autre <code>\b</code>. Maintenant, l&#8217;expression r&eacute;guli&egrave;re lit &#8220;&eacute;galer <code>'ROAD'</code> quand il est un mot entier de par sa nature n&#8217;importe o&ugrave; dans la cha&icirc;ne,&#8221; cela aussi bien &agrave; la fin, qu&#8217;au d&eacute;but, que quelque part au milieu.
</ol>
<p class=a>&#x2042;

<h2 id=romannumerals>&Eacute;tude de cas: Nombres Romains</h2>
<p>Vous avez probablement vu des chiffres romains, m&ecirc;me si vous ne les avez pas reconnu. Vous pouvez les avoir vus dans les droits d&#8217;auteur de vieux films et &eacute;missions de tÃ©lÃ©vision  (&#8220;Copyright <code>MCMXLVI</code>&#8221; au lieu de &#8220;Copyright <code>1946</code>&#8221;), ou sur les murs de d&eacute;dicaces des biblioth&egrave;ques ou des universit&eacute;s (&#8220;fond&eacute;e en <code>MDCCCLXXXVIII</code>&#8221; &agrave; la place de &#8220;fond&eacute;e en <code>1888</code>&#8221;). Vous pourriez aussi les avoir vu dans les sommaires et les r&eacute;f&eacute;rences bibliographiques. C&#8217;est un syst&egrave;me de repr&eacute;sentation des nombres qui remonte vraiment &agrave; l&#8217;ancien empire Romain (d&#8217;o&ugrave; le nom).
<p>Dans la num&eacute;ration Romaine, il y a sept chiffres qui sont r&eacute;p&eacute;t&eacute;s et combin&eacute;s de diff&eacute;rentes fa&ccedil;ons afin de repr&eacute;senter tous les nombres.
<ul>
<li><code>I = 1</code>
<li><code>V = 5</code>
<li><code>X = 10</code>
<li><code>L = 50</code>
<li><code>C = 100</code>
<li><code>D = 500</code>
<li><code>M = 1000</code>
</ul>
<p>Voici quelques r&egrave;gles g&eacute;n&eacute;rales pour construire des nombres Romains:
<ul>
<li>Parfois, les caract&egrave;res sont additifs. <code>I</code> est <code>1</code>, <code>II</code> est <code>2</code>, et <code>III</code> est <code>3</code>. <code>VI</code> est <code>6</code> (litt&eacute;ralement, &#8220;<code>5</code> et <code>1</code>&#8221;), <code>VII</code> est <code>7</code>, et <code>VIII</code> est <code>8</code>.
<li>Les caract&egrave;res de dizaine (<code>I</code>, <code>X</code>, <code>C</code>, et <code>M</code>) peuvent &ecirc;tre r&eacute;p&eacute;t&eacute;s jusqu&#8217;&agrave; trois fois. &Agrave; <code>4</code>, vous devez soustraire du caract&egrave;re suivant le plus haut multiple de cinq &agrave; une puissance de dix. Vous ne pouvez pas repr&eacute;senter <code>4</code> par <code>IIII</code>; au contraire, il est repr&eacute;sent&eacute; par <code>IV</code> (&#8220;<code>1</code> soustrait de <code>5</code>&#8221;). <code>40</code> est repr&eacute;sent&eacute; par <code>XL</code> (&#8220;<code>10</code> soustrait de <code>50</code>&#8221;), <code>41</code> par <code>XLI</code>, <code>42</code> par <code>XLII</code>, <code>43</code> par <code>XLIII</code>, et ensuite <code>44</code> par <code>XLIV</code> (&#8220;<code>10</code> soustrait de <code>50</code>, auquel on ajoute <code>1</code> soustrait de <code>5</code>&#8221;).
<li>Parfois les caract&egrave;res sont&hellip; le contraire d&#8217;additionnable. En mettant certains caract&egrave;res avant d&#8217;autres, vous soustrayez de la valeur finale. Par exemple, pour <code>9</code>, vous devez soustra&icirc;re du caract&egrave;re de la dizaine sup&eacute;rieure: <code>8</code> est <code>VIII</code>, mais <code>9</code> est <code>IX</code> (&#8220;<code>1</code> soustrait de <code>10</code>&#8221;), et pas <code>VIIII</code> (puisque le caract&egrave;re <code>I</code> ne peut pas &ecirc;tre r&eacute;p&eacute;t&eacute; quatre fois). <code>90</code> est <code>XC</code>, <code>900</code> est <code>CM</code>.
<li>Les caract&egrave;res multiples de cinq &agrave; une puissance de dix ne peuvent pas &ecirc;tre r&eacute;p&eacute;t&eacute;s. <code>10</code> est toujours repr&eacute;sent&eacute; par <code>X</code>, jamais par <code>VV</code>. <code>100</code> est toujours <code>C</code>, jamais <code>LL</code>.
<li>Les nombres romains sont lus de gauche &agrave; droite, l&#8217;ordre des caract&egrave;res importe donc &eacute;norm&eacute;ment . <code>DC</code> vaut <code>600</code>; <code>CD</code> est un nombre compl&egrave;tement diff&eacute;rent (<code>400</code>, &#8220;<code>100</code> soustrait de <code>500</code>&#8221;). <code>CI</code> vaut <code>101</code>; <code>IC</code> n&#8217;est m&ecirc;me pas un nombre Romain valide (parceque vous ne pouvez pas soustraire <code>1</code> directement de <code>100</code>; vous auriez &agrave; l&#8217;&eacute;crire  <code>XCIX</code>, &#8220;<code>10</code> soustrait de <code>100</code>, auquel on ajoute <code>1</code> soustrait de <code>10</code>&#8221;).
</ul>
<h3 id=thousands>Contr&ocirc;le des milliers</h3>
<p>Que faudrait-il pour valider une cha&icirc;ne arbitraire de caract&egrave;res en tant que nombre Romain valide? Int&eacute;ressons-nous &agrave; un chiffre &agrave; la fois. Puisque les chiffres Romains sont toujours &eacute;crits du plus grand au plus petit, commen&ccedil;ons par le plus grand: place aux milliers. Pour les nombres 1000 et au-dessus, les milliers sont repr&eacute;sent&eacute;s par une s&eacute;rie de lettres <code>M</code>.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?$'</kbd>        <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106FB58></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106C290></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106AA38></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, '')</kbd>      <span class=u>&#x2465;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106F4A8></samp></pre>
<ol>
<li>Ce pattern est compos&eacute; de trois parties. <code>^</code> correspond seulement &agrave; ce qui suit le d&eacute;but de la cha&icirc;ne. Si ceci n&#8217;&eacute;tait pas sp&eacute;cifi&eacute;, le pattern correspondrait sans tenir compte de l&#8217;emplacement de la lettre <code>M</code>, ce qui n&#8217;est pas ce que vous voulez. Vous voulez &ecirc;tre sur que les lettres <code>M</code>, si elles sont l&agrave;, sont au d&eacute;but de la cha&icirc;ne de caract&egrave;res. <code>M?</code> correspond optionnellement &agrave; un caract&egrave;re <code>M</code> seul. Puisque celui-ci est r&eacute;p&eacute;t&eacute; trois fois, vous &eacute;galez le caract&egrave;re <code>M</code> partout o&ugrave; il appara&icirc;t de z&eacute;ro &agrave; trois fois dans une ligne. Et <code>$</code> &eacute;galise la fin de la cha&icirc;ne de caract&egrave;res. Cela, combin&eacute; avec le caract&egrave;re <code>^</code> au d&eacute;but, signifie que le pattern doit &eacute;galer la cha&icirc;ne enti&egrave;re, avec aucun autre caract&egrave;re avant ou apr&egrave;s le caract&egrave;re <code>M</code>.
<li>L&#8217;essence du module <code>re</code> est la fonction <code>search()</code>, qui prend une expr&eacute;ssion r&eacute;guli&egrave;re (<var>pattern</var>) et une cha&icirc;ne (<code>'M'</code>) pour essayer d&#8217;&eacute;galer l&#8217;expression r&eacute;guli&egrave;re. Si une correspondance est trouv&eacute;e, <code>search()</code> retourne un objet aux m&eacute;thodes vari&eacute;es afin de d&eacute;crire la correspondance; si aucune correspondance n&#8217;est trouv&eacute;e, <code>search()</code> retourne <code>None</code>, la valeur nulle de Python. Tout ce qui vous pr&eacute;occupe en ce moment est de savoir si le pattern est reconnu, ce que vous pouvez dire juste en regardant la valeur de retour de <code>search()</code>. <code>'M'</code> correspond &agrave; cette expression r&eacute;guli&egrave;re, car le premier <code>M</code> optionnel correspond et le second et le troisi&egrave;me caract&egrave;res <code>M</code> optionnels sont ignor&eacute;s.
<li><code>'MM'</code> correspond car le premier et le second caract&egrave;re optionnel <code>M</code> correspondent et le troisi&egrave;me <code>M</code> est ignor&eacute;.
<li><code>'MMM'</code> correspond car chacun des trois caract&egrave;res <code>M</code> correspond.
<li><code>'MMMM'</code> ne correspond pas. Chacun des trois caract&egrave;res <code>M</code> correspond, mais ensuite l&#8217;expression r&eacute;guli&egrave;re insiste sur la fin de la cha&icirc;ne (&agrave; cause du caract&egrave;re <code>$</code>), cependant la cha&icirc;ne de caract&egrave;res ne se termine toujours pas (&agrave; cause des quatre <code>M</code>). Donc <code>search()</code> retourne <code>None</code>.
<li>Fait int&eacute;ressant, une cha&icirc;ne vide correspond aussi &agrave; cette expression r&eacute;guli&egrave;re, puisque tous les caract&egrave;res <code>M</code> sont optionnels.
</ol>
<h3 id=hundreds>Contr&ocirc;le des centaines</h3>
<aside>? rend un pattern optionnel.</aside>
<p>Le cas des centaines est plus difficile que celui des milliers parce qu&#8217;il y a plusieurs mani&egrave;res mutuellement exclusives par lesquelles il pourrait &ecirc;tre exprim&eacute;, d&eacute;pendant de sa valeur.
<ul>
<li><code>100 = C</code>
<li><code>200 = CC</code>
<li><code>300 = CCC</code>
<li><code>400 = CD</code>
<li><code>500 = D</code>
<li><code>600 = DC</code>
<li><code>700 = DCC</code>
<li><code>800 = DCCC</code>
<li><code>900 = CM</code>
</ul>
<p>Il ya donc quatre patterns possibles:
<ul>
<li><code>CM</code>
<li><code>CD</code>
<li>De z&eacute;ro &agrave; trois caract&egrave;res <code>C</code> (z&eacute;ro si les centaines valent 0)
<li><code>D</code>, suivi de z&eacute;ro &agrave; trois caract&egrave;res <code>C</code>
</ul>
<p>Les deux derniers patterns peuvent &ecirc;tre combin&eacute;s:
<ul>
<li>un <code>D</code> optionnel, suivi de z&eacute;ro &agrave; trois caract&egrave;res <code>C</code>
</ul>
<p>Cet exemple montre comment valider les centaines d&#8217;un chiffre Romain.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)$'</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCM')</kbd>             <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 01070390></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MD')</kbd>              <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 01073A50></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMCCC')</kbd>          <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 010748A8></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMC')</kbd>            <span class=u>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, '')</kbd>                <span class=u>&#x2465;</span></a>
<samp>&lt;_sre.SRE_Match object at 01071D98></samp></pre>
<ol>
<li>Ce pattern commence de la m&ecirc;me fa&ccedil;on que le pr&eacute;c&eacute;dent, en v&eacute;rifiant le d&eacute;but de la cha&icirc;ne (<code>^</code>), puis les milliers (<code>M?M?M?</code>). Ensuite, il a la nouvelle partie, entre parenth&egrave;ses, qui d&eacute;finit un ensemble de trois patterns mutuellement exclusifs, s&eacute;par&eacute;s par des barres verticales:  <code>CM</code>, <code>CD</code>, et <code>D?C?C?C?</code> (qui est un <code>D</code> optionnel suivi par aucun &agrave; trois caract&egrave;res <code>C</code> optionnels). Le parser (analyseur syntaxique) des expressions r&eacute;guli&egrave;res contr&ocirc;le chacun des ces patterns dans l&#8217;ordre (de la gauche vers la droite), prend le premier qui correspond et ignore le reste.
<li><code>'MCM'</code> est reconnu car le premier <code>M</code> correspond, les deuxi&egrave;me et troisi&egrave;me caract&egrave;res <code>M</code> sont ignor&eacute;s, et le <code>CM</code> correspond (donc les patterns <code>CD</code> et <code>D?C?C?C?</code>  ne sont m&ecirc;me pas pris en compte). <code>MCM</code> est la repr&eacute;sentation en nombres Romains de <code>1900</code>.
<li><code>'MD'</code> est reconnu car le premier <code>M</code> correspond, les deuxi&egrave;me et troisi&egrave;me caract&egrave;res <code>M</code> sont ignor&eacute;s, et le pattern <code>D?C?C?C?</code> reconna&icirc;t <code>D</code> (chacun des trois caract&egrave;res <code>C</code> est optionnel et est ignor&eacute;). <code>MD</code> est la repr&eacute;sentation en nombres Romains de <code>1500</code>.
<li><code>'MMMCCC'</code> est reconnu car chacun des trois caract&egrave;res <code>M</code> correspond, et le pattern <code>D?C?C?C?</code> reconna&icirc;t <code>CCC</code> (le <code>D</code> est optionnel et est ignor&eacute;). <code>MMMCCC</code> est la repr&eacute;sentation en chiffres Romains de <code>3300</code>.
<li><code>'MCMC'</code> ne peut pas &ecirc;tre reconnu. Le premier <code>M</code> correspond, les deuxi&egrave;me et troisi&egrave;me caract&egrave;res <code>M</code> sont ignor&eacute;, et le <code>CM</code> correspond, mais ensuite le <code>$</code> ne correspond pas car vous n&#8217;&ecirc;tes pas encore &agrave; la fin de la cha&icirc;ne (vous avez encore un caract&egrave;re <code>C</code> qui ne correspond pas). Le <code>C</code> <em>ne</em> correspond <em>pas</em> &agrave; une partie du pattern <code>D?C?C?C?</code>, parceque le pattern mutuellement exclusif <code>CM</code> a d&eacute;j&agrave; &eacute;t&eacute; &eacute;gal&eacute;.
<li>Fait int&eacute;ressant, une cha&icirc;ne vide correspond toujours &agrave; ce pattern, parce que tous les caract&egrave;res <code>M</code> sont optionnels et ignor&eacute;s, et la cha&icirc;ne vide correspond au pattern <code>D?C?C?C?</code> dans lequel tous les caract&egrave;res sont optionnels et ignorÃ©s.
</ol>
<p>Ouf! Voyez comment les expressions r&eacute;guli&egrave;res peuvent devenir compliqu&eacute;es? Et nous n&#8217;avons vu l&agrave; que les cas traitant les milliers et les centaines des chiffres Romains. Mais si vous avez suivi tout cela, les dizaines et les unit&eacute;s sont relativement simples, car ils sont bas&eacute;s exactement sur le m&ecirc;me pattern. Mais penchons-nous sur une autre fa&ccedil;on d&#8217;exprimer le pattern.
<p class=a>&#x2042;

<h2 id=nmsyntax>Utilisation de la syntaxe <code>{n,m}</code></h2>
<aside>{1,4} &eacute;galises les occurences 1 et 4 d&#8217;un pattern.</aside>
<p>Dans la section pr&eacute;c&eacute;dente, vous traitiez avec un pattern o&ugrave; le m&ecirc;me caract&egrave;re pouvait &ecirc;tre r&eacute;p&eacute;t&eacute; jusqu'&agrave; trois fois. Il y a un autre moyen d&#8217;exprimer ceci &agrave; travers les expressions r&eacute;guli&egrave;res, que certaine personnes trouve plus lisible. En premier lieu observons la m&eacute;thode que nous avions d&eacute;j&agrave; utilis&eacute; dans l&#8217;exemple pr&eacute;c&eacute;dent.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?$'</kbd>
<a><samp>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis au premier <code>M</code> optionnel, mais ni au second ni au troisi&egrave;me <code>M</code> (mais tout roule car ils sont optionnels), et ensuite &agrave; la fin de la cha&icirc;ne.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis au premier et au second <code>M</code> optionnels, mais pas au troisi&egrave;me <code>M</code> (mais tout roule car il est optionnel), et ensuite &agrave; la fin de la cha&icirc;ne.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis &agrave; chacun des trois <code>M</code> optionnels, et ensuite &agrave; la fin de la cha&icirc;ne.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis &agrave; chacun des trois <code>M</code> optionnels, mais ensuite ne correspond pas &agrave; la fin de la cha&icirc;ne (car il y a encore un <code>M</code> non valide), le pattern ne correspond donc pas et retourne <code>None</code>.
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M{0,3}$'</kbd>        <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEDA8></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2464;</span></a>
<samp>>>> </samp></pre>
<ol>
<li>Ce pattern dit: &#8220;&Eacute;galer le d&eacute;but de la cha&icirc;ne, puis n&#8217;importe o&ugrave; de z&eacute;ro &agrave; trois caract&egrave;res <code>M</code>, puis la fin de la cha&icirc;ne.&#8221;  Le 0 et le 3 peuvent &ecirc;tre n&#8217;importe quel nombre; si vous voulez faire correspondre au moins un mais pas plus de trois caract&egrave;res <code>M</code>, vous pouvez mettre <code>M{1,3}</code>.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis &agrave; un <code>M</code> sur trois possibles, puis &agrave; la fin de la cha&icirc;ne.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis &agrave; deux <code>M</code> sur trois possibles, puis &agrave; la fin de la cha&icirc;ne.
<li>Ceci correspond au  d&eacute;but de la cha&icirc;ne, puis &agrave; trois <code>M</code> sur trois possibles, puis &agrave; la fin de la cha&icirc;ne.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis &agrave; trois <code>M</code> sur trois possibles, mais ensuite <em>ne correspond pas</em> &agrave; la fin de la cha&icirc;ne. L&#8217;expression r&eacute;guli&egrave;re permet jusqu&#8217;&agrave; trois caract&egrave;res <code>M</code> avant la fin de la cha&icirc;ne, mais vous en avez quatre, le pattern ne correspond donc pas et retourne <code>None</code>.
</ol>
<h3 id=tensandones>Contr&ocirc;le des dizaines et des unit&eacute;s</h3>
<p>Maintenant allons &eacute;tendre l&#8217;expression r&eacute;guli&egrave;re des nombres romains pour couvrir les cas des dizaines et des unit&eacute;s. Cet exemple montre le contr&ocirc;le des dizaines.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMXL')</kbd>     <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCML')</kbd>      <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLX')</kbd>     <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXX')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXXX')</kbd>  <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis au premier <code>M</code> optionnel, puis au <code>CM</code>, puis au <code>XL</code>, puis &agrave; la fin de la cha&icirc;ne. Rappelez-vous, la syntaxe <code>(A|B|C)</code>signifie &#8220;&eacute;galez de fa&ccedil;on exacte l&#8217;un des termes A, B, ou C&#8221;. Vous &eacute;galez <code>XL</code>, donc vous ignorez les choix <code>XC</code> et <code>L?X?X?X?</code>, ensuite passez &agrave; la fin de la cha&icirc;ne. <code>MCMXL</code> est la repr&eacute;sentation en nombres Romain de <code>1940</code>.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis au premier <code>M</code> optionnel, puis au <code>CM</code>, puis au <code>L?X?X?X?</code>. Parmis les <code>L?X?X?X?</code>, il reconna&icirc;t <code>L</code> et saute tous les trois caract&egrave;res <code>X</code> optionnels. Ensuite, vous passez &agrave; la fin de la cha&icirc;ne. <code>MCML</code> est la repr&eacute;sentation en nombres Romains de <code>1950</code>.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis au premier <code>M</code> optionnel, puis au <code>CM</code>, puis au <code>L</code> optionnel et au premier <code>X</code> optionnel, saute le deuxi&egrave;me et le troisi&egrave;me <code>X</code> optionnels, puis &agrave; la fin de la cha&icirc;ne. <code>MCMLX</code> est la repr&eacute;sentation en nombres Romains de <code>1960</code>.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis au premier <code>M</code> optionnel, puis au <code>CM</code>, puis au <code>L</code> optionnel et chacun des trois caract&egrave;res <code>X</code> optionnels, puis &agrave; la fin de la cha&icirc;ne. <code>MCMLXXX</code> est la repr&eacute;sentation en nombres Romains de <code>1980</code>.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis au premier <code>M</code> optionnel, puis au <code>CM</code>, puis au <code>L</code> optionnel et chacun des trois caract&egrave;res <code>X</code> optionnels, puis <em>&eacute;choue &agrave; reconna&icirc;tre</em> la fin de la cha&icirc;ne car il y a encore un <code>X</code> de plus qui manque. Le pattern entier &eacute;choue donc sa reconnaissance et retourne <code>None</code>. <code>MCMLXXXX</code> n&#8217;est pas un nombre Romain valide.
</ol>
<aside>(A|B) correspond au pattern A ou au pattern B, mais pas au deux.</aside>
<p>L&#8217;expression pour le cas des unit&eacute;s suit le m&ecirc;me sch&eacute;ma. Je vais vous &eacute;pargner les d&eacute;tails et vous montrer le r&eacute;sultat final.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$'</kbd>
</pre><p>Qu&#8217;est-ce qui ressemble donc &agrave; l&#8217;utilisation de cette syntaxe altern&eacute;e <code>{n,m}</code> ?  Cet exemple montre la nouvelle syntaxe.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MDLV')</kbd>              <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMDCLXVI')</kbd>          <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMDCCCLXXXVIII')</kbd>   <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'I')</kbd>                 <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp></pre>
<ol>
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis &agrave; l&#8217;un des trois caract&egrave;res <code>M</code> possibles, puis au <code>D?C{0,3}</code>. Sur ce, il reconna&icirc;t le <code>D</code> optionnel et de z&eacute;ro &agrave; trois caract&egrave;res <code>C</code> optionnels. En cours de route, il reconna&icirc;t <code>L?X{0,3}</code> en &eacute;galisant le <code>L</code> optionnel et de z&eacute;ro &agrave; trois caract&egrave;res <code>X</code> possibles. Puis il reconna&icirc;t <code>V?I{0,3}</code> en &eacute;galisant le <code>V</code> et de z&eacute;ro &agrave; trois caract&egrave;res  <code>I</code> possibles, et finalement la fin de la cha&icirc;ne. <code>MDLV</code> est la repr&eacute;sentation en nombres Romain de <code>1555</code>.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis &agrave; deux des trois caract&egrave;res <code>M</code> possibles, puis au <code>D?C{0,3}</code> avec un <code>D</code> et un des trois caract&egrave;res <code>C</code> possibles; puis au <code>L?X{0,3}</code> avec un <code>L</code> et un des trois caract&egrave;res <code>X</code> possibles; puis au <code>V?I{0,3}</code> avec un <code>V</code> et un des trois caract&egrave;res <code>I</code> possibles; puis &agrave; la fin de la cha&icirc;ne. <code>MMDCLXVI</code> est la repr&eacute;sentation en nombres Romain de <code>2666</code>.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis &agrave; trois des trois caract&egrave;res <code>M</code> possibles, puis au <code>D?C{0,3}</code> avec un <code>D</code> et trois caract&egrave;res <code>C</code> sur trois; puis au <code>L?X{0,3}</code> avec un <code>L</code> et trois caract&egrave;res <code>X</code> sur trois; puis au <code>V?I{0,3}</code> avec un <code>V</code> et trois caract&egrave;res <code>I</code> sur trois; puis &agrave; la fin de la cha&icirc;ne. <code>MMMDCCCLXXXVIII</code> est la repr&eacute;sentation en nombres Romain de <code>3888</code>, et c&#8217;est le chiffre Romain le plus long que vous pouvez &eacute;crire sans syntaxe &eacute;tendue.
<li>Regardez attentivement. (Je me sens dans la peau d&#8217;un magicien. &#8220;Regardez attentivement les enfants, je vais sortir un lapin de mon chapeau.&#8221;)  Ceci correspond au d&eacute;but de la cha&icirc;ne, puis  &agrave; z&eacute;ro <code>M</code> sur trois, puis correspond au <code>D?C{0,3}</code> en sautant le <code>D</code> optionnel et en &eacute;galisant  z&eacute;ro <code>C</code> sur trois, puis correspond au <code>L?X{0,3}</code> en sautant le <code>L</code> optionnel et en &eacute;galisant z&eacute;ro <code>X</code> sur trois, puis correspond au <code>V?I{0,3}</code> en sautant le <code>V</code> optionnel et &eacute;galisant un <code>I</code> sur trois. Puis &agrave; la fin de la cha&icirc;ne. Ouha.
</ol>
<p>Si vous avez suivi tout cela et bien compris du premier coup, vous faites mieux que moi. Maintenant imaginez essayer de comprendre les expressions r&eacute;guli&egrave;res de quelqu&#8217;un d&#8217;autre, au milieu d&#8217;une fonction critique d&#8217;un vaste programme. Ou m&ecirc;me imaginez revenir &agrave; vos propres expressions r&eacute;guli&egrave;res quelques mois plus tard. Je l&#8217;ai fait, et ce n&#8217;est pas beau &agrave; voir.
<p>Nous allons maintenant explorer une syntaxe alternative qui permet de faciliter la maintenance de vos expressions r&eacute;guli&egrave;res.
<p class=a>&#x2042;

<h2 id=verbosere>Expressions R&eacute;guli&egrave;res Verbeuses</h2>
<p>Jusqu&#8217;ici vous n&#8217;avez eu affaire qu&#8217;&agrave; ce que j&#8217;appelerais des expressions r&eacute;guli&egrave;res &#8220;compactes&#8221;. Comme vous l&#8217;avez vu, elles sont difficiles &agrave; lire et m&ecirc;me si vous comprenez ce que fait l&#8217;une d&#8217;entre elles, il n&#8217;y a pas de garanties que vous serez encore capable de le comprendre six mois plus tard. Ce dont vous avez r&eacute;llement besoin, c&#8217;est d&#8217;une documentation int&eacute;gr&eacute;e.
<p>Python vous permet de le faire avec ce qu&#8217;on appelle  des <i>expressions r&eacute;guli&egrave;res verbeuses</i>. Une expression r&eacute;guli&egrave;re verbeuse est diff&eacute;rente d&#8217;une expression r&eacute;guli&egrave;re compacte de deux mani&egrave;res:
<ul>
<li>Les espaces blancs sont ignor&eacute;s. Les espaces, les tabulations et les retours chariot ne sont pas reconnus en tant qu&#8217;espaces, tabulations et retours chariot. Ils ne sont pas reconnus du tous. (Si vous voulez reconna&icirc;tre un espace dans une expression r&eacute;guli&egrave;re verbeuse, vous aurez &agrave; &eacute;chapper ce caract&egrave;re en rajoutant un antislash devant celui-ci.)
<li>Les commentaires sont ignor&eacute;s. Un commentaire dans une expression r&eacute;guli&egrave;re verbeuse est exactement comme un commentaire dans du code Python: il commence par un caract&egrave;re <code>#</code> et se poursuit jusqu&#8217;&agrave; la fin de la ligne. Dans ce cas, il s&#8217;agit d&#8217;un commentaire dans une cha&icirc;ne multi-lignes plut&ocirc;t que dans votre code source, mais il fonctionne de la m&egrave;me mani&egrave;re.
</ul>
<p>Ce sera plus clair avec un exemple. Allons revisiter l&#8217;expression r&eacute;guli&egrave;re compacte avec laquelle vous avez travaill&eacute;, et transformons la en expression r&eacute;guli&egrave;re verbeuse. Cet exemple montre comment.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '''
    ^                   # d&eacute;but de la cha&icirc;ne
    M{0,3}              # milliers - de 0 &agrave; 3 M
    (CM|CD|D?C{0,3})    # centaines - 900 (CM), 400 (CD), 0-300 (de 0 &agrave; 3 C),
                        #             ou 500-800 (D, suivi de 0 &agrave; 3 C)
    (XC|XL|L?X{0,3})    # dizaines - 90 (XC), 40 (XL), 0-30 (de 0 &agrave; 3 X),
                        #            ou 50-80 (L, suivi de 0 &agrave; 3 X)
    (IX|IV|V?I{0,3})    # unit&eacute;s - 9 (IX), 4 (IV), 0-3 (de 0 &agrave; 3 I),
                        #          5-8 (V, suivi de 0 &agrave; 3 Is)
    $                   # fin de la cha&icirc;ne
    '''</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M', re.VERBOSE)</kbd>                 <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXXIX', re.VERBOSE)</kbd>         <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMDCCCLXXXVIII', re.VERBOSE)</kbd>   <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>                             <span class=u>&#x2463;</span></a></pre>
<ol>
<li>La chose la plus importante &agrave; retenir lors de l&#8217;utilisation des expressions r&eacute;guli&egrave;res verbeuses est que vous avez besoin de passer un argument suppl&eacute;mentaire lorsque vous travaillez avec celles-ci: <code>re.VERBOSE</code> est une constante d&eacute;finie dans le module <code>re</code> qui signale que le pattern doit &ecirc;tre trait&eacute; comme une expression r&eacute;guli&egrave;re verbeuse. Comme vous pouvez le constater, ce pattern comporte quelques espaces blancs (qui sont tous ignor&eacute;s), et plusieurs commentaires (qui sont tous ignor&eacute;s). Une fois que vous avez ignor&eacute; les espaces et les commentaires, c&#8217;est exactement la m&ecirc;me expression r&eacute;guli&egrave;re que vous avez vu dans la section pr&eacute;c&eacute;dente, mais en beaucoup plus lisible.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis &agrave; l&#8217;un des trois <code>M</code> possibles, puis &agrave; <code>CM</code>, puis &agrave; <code>L</code> et &agrave; trois des trois <code>X</code> possibles, puis &agrave; <code>IX</code>, puis &agrave; la fin de la cha&icirc;ne.
<li>Ceci correspond au d&eacute;but de la cha&icirc;ne, puis &agrave; trois des trois <code>M</code> possibles, puis &agrave; <code>D</code> et &agrave; trois des trois  <code>C</code> possibles, puis &agrave; <code>L</code> et &agrave; trois des trois <code>X</code> possibles, puis &agrave; <code>V</code> et &agrave; trois des trois  <code>I</code> possibles, puis &agrave; la fin de la cha&icirc;ne.
<li>Cela ne correspond pas. Pourquoi? Parce qu'il n'a pas  l&#8217;appel <code>re.VERBOSE</code>,  de sorte que la fonction <code>re.search</code> traite le pattern comme une expression r&eacute;guli&egrave;re compacte, avec un espace blanc important et des marques de hachage litt&eacute;rale. Python ne peut pas d&eacute;tecter automatiquement si une expression r&eacute;guli&egrave;re est verbeuse ou non. Python consid&egrave;re que chaque expression r&eacute;guli&egrave;re est compacte, &agrave; moins que vous ne pr&eacute;cisiez explicitement qu&#8217;elle est verbeuse.
</ol>
<p class=a>&#x2042;

<h2 id=phonenumbers>&Eacute;tude de cas: Analyse Syntaxique de Num&eacute;ros de t&eacute;l&eacute;phone </h2>
<aside>\d correspond &agrave; tout chiffre numÃ©rique (0&ndash;9). \D correspond &agrave; tout sauf &agrave; des chiffres. </aside>
<p>Jusqu&#8217;ici, vous vous &ecirc;tes concentr&eacute;s sur la reconnaissance de pattern complets. Soit le pattern est reconnu, soit il ne l&#8217;est pas. Mais les expressions r&eacute;guli&egrave;res sont beaucoup plus puissantes que cela. Quand une expression r&eacute;guli&egrave;re correspond <em>bien</em>, vous pouvez s&eacute;lectionner certaines parties sp&eacute;cifiques de celles-ci. Vous pouvez d&eacute;couvrir ce qui correspond et o&ugrave; cela correspond.
<p>Cet exemple est venu d&#8217;un autre probl&egrave;me r&eacute;el que j&#8217;ai rencontr&eacute;, issu une fois plus de mon experience professionnelle. Le probl&egrave;me: l&#8217;analyse syntaxique d&#8217;un num&eacute;ro de t&eacute;l&eacute;phone am&eacute;ricain. Le client voulait &ecirc;tre en mesure de saisir le num&eacute;ro sans contrainte de forme (dans un seul champ de saisie), mais voulait ensuite stocker le code r&eacute;gional, l&#8217;indicatif, le nombre, et &eacute;ventuellement une extension s&eacute;par&eacute;e dans la base de donn&eacute;es de l&#8217;entreprise. J&#8217;ai parcouru le Web et trouv&eacute; de nombreux exemples d&#8217;expressions r&eacute;guli&egrave;res qui visait &agrave; le faire, mais aucune d&#8217;entre elles n&#8217;Ã©tait assez souple.
<p>Voici les numÃ©ros de t&eacute;l&eacute;phone que je devais &ecirc;tre en mesure d&#8217;accepter:
<ul>
<li><code>800-555-1212</code>
<li><code>800 555 1212</code>
<li><code>800.555.1212</code>
<li><code>(800) 555-1212</code>
<li><code>1-800-555-1212</code>
<li><code>800-555-1212-1234</code>
<li><code>800-555-1212x1234</code>
<li><code>800-555-1212 ext. 1234</code>
<li><code>work 1-(800) 555.1212 #1234</code>
</ul>
<p>Que de vari&eacute;t&eacute;s! Dans chacun de ces cas, j&#8217;avais besoin de savoir que le code r&eacute;gional &eacute;tait <code>800</code>, l&#8217;indicatif <code>555</code>, et le reste du num&eacute;ro  <code>1212</code>. Pour ceux avec une extension, j&#8217;avais besoin de savoir que l&#8217;extension &eacute;tait  <code>1234</code>.
<p>Nous devons travailler &agrave; l&#8217;&eacute;laboration d&#8217;une solution d&#8217;analyse syntaxique de num&eacute;ro de t&eacute;l&eacute;phone. Cet exemple montre la premi&egrave;re &eacute;tape.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})-(\d{3})-(\d{4})$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234')</kbd>                 <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>        <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AttributeError: 'NoneType' object has no attribute 'groups'</samp></pre>
<ol>
<li>Lisez toujours les expressions r&eacute;guli&egrave;res de gauche &agrave; droite. Celle-ci correspond au d&eacute;but de la cha&icirc;ne, puis au <code>(\d{3})</code>. Que repr&eacute;sente <code>\d{3}</code>?  Et bien, <code>\d</code> signifie &#8220;n&#8217;importe quel chiffre&#8221; (de 0 &agrave; <code>9</code>). Le <code>{3}</code> signifie &#8220;&eacute;galez exactement trois chiffres&#8221;; c&#8217;est une variation de <a href=#nmsyntax><code>la syntaxe {n,m}</code></a> vue plus t&ocirc;t. Le glisser enti&egrave;rement entre parenth&egrave;ses signifie &#8220;&eacute;galez exactement trois chiffres, <em>et ensuite s&#8217;en rappeler en tant qu&#8217;un groupe que je pourrais rappeler par la suite</em>&#8221;. Puis &eacute;galez un tiret. Puis &eacute;galez un autre groupe d&#8217;exactement trois chiffres. Puis un autre tiret. Puis un autre groupe d&#8217;exactement quatre chiffres. Puis &eacute;galez la fin de la chaÃ®ne.
<li>Pour avoir acc&egrave;s au groupe m&eacute;moris&eacute; tout au long du chemin par l&#8217;analyseur syntaxique de l&#8217;expression r&eacute;guli&egrave;re, utlisez la m&eacute;thode <code>groups()</code> sur l&#8217;objet que la m&eacute;thode <code>search()</code> retourne. Ceci retournera syst&eacute;matiquement un tuple (ndlt: ou t-uple contraction de table-uple, c&#8217;est &agrave; dire une collection d&#8217;objet pr&eacute;sent&eacute; sous forme de tableau, de table) de nombreux groupes qui &eacute;taient d&eacute;finis dans l&#8217;expression r&eacute;guli&egrave;re. Dans ce cas, vous avez d&eacute;fini trois groupes, l&#8217;un &agrave; trois chiffres, suivi d&#8217;un autre &agrave; trois chiffre et un &agrave; quatre chiffres pour finir.
<li>This regular expression is not the final answer, because it doesn&#8217;t handle a phone number with an extension on the end. For that, you&#8217;ll need to expand the regular expression.
<li>And this is why you should never &#8220;chain&#8221; the <code>search()</code> and <code>groups()</code> methods in production code. If the <code>search()</code> method returns no matches, it returns <a href=native-datatypes.html#none><code>None</code></a>, not a regular expression match object. Calling <code>None.groups()</code> raises a perfectly obvious exception: <code>None</code> doesn&#8217;t have a <code>groups()</code> method. (Of course, it&#8217;s slightly less obvious when you get this exception from deep within your code. Yes, I speak from experience here.)
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})-(\d{3})-(\d{4})-(\d+)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>              <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800 555 1212 1234')</kbd>                       <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                            <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>This regular expression is almost identical to the previous one. Just as before, you match the beginning of the string, then a remembered group of three digits, then a hyphen, then a remembered group of three digits, then a hyphen, then a remembered group of four digits. What&#8217;s new is that you then match another hyphen, and a remembered group of one or more digits, then the end of the string.
<li>The <code>groups()</code> method now returns a tuple of four elements, since the regular expression now defines four groups to remember.
<li>Unfortunately, this regular expression is not the final answer either, because it assumes that the different parts of the phone number are separated by hyphens. What if they&#8217;re separated by spaces, or commas, or dots?  You need a more general solution to match several different types of separators.
<li>Oops! Not only does this regular expression not do everything you want, it&#8217;s actually a step backwards, because now you can&#8217;t parse phone numbers <em>without</em> an extension. That&#8217;s not what you wanted at all; if the extension is there, you want to know what it is, but if it&#8217;s not there, you still want to know what the different parts of the main number are.
</ol>
<p>The next example shows the regular expression to handle separators between the different parts of the phone number.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})\D+(\d{3})\D+(\d{4})\D+(\d+)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800 555 1212 1234').groups()</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234')</kbd>              <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Hang on to your hat. You&#8217;re matching the beginning of the string, then a group of three digits, then <code>\D+</code>. What the heck is that?  Well, <code>\D</code> matches any character <em>except</em> a numeric digit, and <code>+</code> means &#8220;1 or more&#8221;. So <code>\D+</code> matches one or more characters that are not digits. This is what you&#8217;re using instead of a literal hyphen, to try to match different separators.
<li>Using <code>\D+</code> instead of <code>-</code> means you can now match phone numbers where the parts are separated by spaces instead of hyphens.
<li>Of course, phone numbers separated by hyphens still work too.
<li>Unfortunately, this is still not the final answer, because it assumes that there is a separator at all. What if the phone number is entered without any spaces or hyphens at all?
<li>Oops! This still hasn&#8217;t fixed the problem of requiring extensions. Now you have two problems, but you can solve both of them with the same technique.
</ol>
<p>The next example shows the regular expression for handling phone numbers <em>without</em> separators.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234').groups()</kbd>      <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800.555.1212 x1234').groups()</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>        <span class=u>&#x2463;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('(800)5551212 x1234')</kbd>           <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>The only change you&#8217;ve made since that last step is changing all the <code>+</code> to <code>*</code>. Instead of <code>\D+</code> between the parts of the phone number, you now match on <code>\D*</code>. Remember that <code>+</code> means &#8220;1 or more&#8221;?  Well, <code>*</code> means &#8220;zero or more&#8221;. So now you should be able to parse phone numbers even when there is no separator character at all.
<li>Lo and behold, it actually works. Why?  You matched the beginning of the string, then a remembered group of three digits (<code>800</code>), then zero non-numeric characters, then a remembered group of three digits (<code>555</code>), then zero non-numeric characters, then a remembered group of four digits (<code>1212</code>), then zero non-numeric characters, then a remembered group of an arbitrary number of digits (<code>1234</code>), then the end of the string.
<li>Other variations work now too: dots instead of hyphens, and both a space and an <code>x</code> before the extension.
<li>Finally, you&#8217;ve solved the other long-standing problem: extensions are optional again. If no extension is found, the <code>groups()</code> method still returns a tuple of four elements, but the fourth element is just an empty string.
<li>I hate to be the bearer of bad news, but you&#8217;re not finished yet. What&#8217;s the problem here?  There&#8217;s an extra character before the area code, but the regular expression assumes that the area code is the first thing at the beginning of the string. No problem, you can use the same technique of &#8220;zero or more non-numeric characters&#8221; to skip over the leading characters before the area code.
</ol>
<p>The next example shows how to handle leading characters in phone numbers.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^\D*(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('(800)5551212 ext. 1234').groups()</kbd>                  <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>                            <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234')</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>This is the same as in the previous example, except now you&#8217;re matching <code>\D*</code>, zero or more non-numeric characters, before the first remembered group (the area code). Notice that you&#8217;re not remembering these non-numeric characters (they&#8217;re not in parentheses). If you find them, you&#8217;ll just skip over them and then start remembering the area code whenever you get to it.
<li>You can successfully parse the phone number, even with the leading left parenthesis before the area code. (The right parenthesis after the area code is already handled; it&#8217;s treated as a non-numeric separator and matched by the <code>\D*</code> after the first remembered group.)
<li>Just a sanity check to make sure you haven&#8217;t broken anything that used to work. Since the leading characters are entirely optional, this matches the beginning of the string, then zero non-numeric characters, then a remembered group of three digits (<code>800</code>), then one non-numeric character (the hyphen), then a remembered group of three digits (<code>555</code>), then one non-numeric character (the hyphen), then a remembered group of four digits (<code>1212</code>), then zero non-numeric characters, then a remembered group of zero digits, then the end of the string.
<li>This is where regular expressions make me want to gouge my eyes out with a blunt object. Why doesn&#8217;t this phone number match? Because there&#8217;s a <code>1</code> before the area code, but you assumed that all the leading characters before the area code were non-numeric characters (<code>\D*</code>). Aargh.
</ol>
<p>Let&#8217;s back up for a second. So far the regular expressions have all matched from the beginning of the string. But now you see that there may be an indeterminate amount of stuff at the beginning of the string that you want to ignore. Rather than trying to match it all just so you can skip over it, let&#8217;s take a different approach: don&#8217;t explicitly match the beginning of the string at all. This approach is shown in the next example.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234').groups()</kbd>         <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>                        <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234').groups()</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp></pre>
<ol>
<li>Note the lack of <code>^</code> in this regular expression. You are not matching the beginning of the string anymore. There&#8217;s nothing that says you need to match the entire input with your regular expression. The regular expression engine will do the hard work of figuring out where the input string starts to match, and go from there.
<li>Now you can successfully parse a phone number that includes leading characters and a leading digit, plus any number of any kind of separators around each part of the phone number.
<li>Sanity check. This still works.
<li>That still works too.
</ol>
<p>See how quickly a regular expression can get out of control?  Take a quick glance at any of the previous iterations. Can you tell the difference between one and the next?
<p>While you still understand the final answer (and it is the final answer; if you&#8217;ve discovered a case it doesn&#8217;t handle, I don&#8217;t want to know about it), let&#8217;s write it out as a verbose regular expression, before you forget why you made the choices you made.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'''
                # don't match beginning of string, number can start anywhere
    (\d{3})     # area code is 3 digits (e.g. '800')
    \D*         # optional separator is any number of non-digits
    (\d{3})     # trunk is 3 digits (e.g. '555')
    \D*         # optional separator
    (\d{4})     # rest of number is 4 digits (e.g. '1212')
    \D*         # optional separator
    (\d*)       # extension is optional and can be any number of digits
    $           # end of string
    ''', re.VERBOSE)</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234').groups()</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                          <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp></pre>
<ol>
<li>Other than being spread out over multiple lines, this is exactly the same regular expression as the last step, so it&#8217;s no surprise that it parses the same inputs.
<li>Final sanity check. Yes, this still works. You&#8217;re done.
</ol>
<p class=a>&#x2042;

<h2 id=summary>Summary</h2>
<p>This is just the tiniest tip of the iceberg of what regular expressions can do. In other words, even though you&#8217;re completely overwhelmed by them now, believe me, you ain&#8217;t seen nothing yet.
<p>You should now be familiar with the following techniques:
<ul>
<li><code>^</code> correspond au d&eacute;but de la cha&icirc;ne.
<li><code>$</code> correspond &agrave; la fin de la cha&icirc;ne.
<li><code>\b</code> matches a word boundary.
<li><code>\d</code> matches any numeric digit.
<li><code>\D</code> matches any non-numeric character.
<li><code>x?</code> matches an optional <code>x</code> character (in other words, it matches an <code>x</code> zero or one times).
<li><code>x*</code> matches <code>x</code> zero or more times.
<li><code>x+</code> matches <code>x</code> one or more times.
<li><code>x{n,m}</code> matches an <code>x</code> character at least <code>n</code> times, but not more than <code>m</code> times.
<li><code>(a|b|c)</code> matches exactly one of <code>a</code>, <code>b</code> or <code>c</code>.
<li><code>(x)</code> in general is a <em>remembered group</em>. You can get the value of what matched by using the <code>groups()</code> method of the object returned by <code>re.search</code>.
</ul>
<p>Regular expressions are extremely powerful, but they are not the correct solution for every problem. You should learn enough about them to know when they are appropriate, when they will solve your problems, and when they will cause more problems than they solve.
<p class=v><a href=strings.html rel=prev title='back to &#8220;Strings&#8221;'><span class=u>&#x261C;</span></a> <a href=generators.html rel=next title='onward to &#8220;Closures &amp; Generators&#8221;'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;10 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
