<!DOCTYPE html>
<meta charset=utf-8>
<title>Closures &amp; G&eacute;n&eacute;rateurs - Plongez au c&oelig;ur de Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 6}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Rechercher></div></form>
<p>Vous &ecirc;tes ici : <a href=index.html>Accueil</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#generators>Plongez au c&oelig;ur de Python 3</a> <span class=u>&#8227;</span>
<p id=level>Niveau de difficult&eacute; : <span class=u title=intermediate>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Closures <i class=baa>&amp;</i> G&eacute;n&eacute;rateurs</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> My spelling is Wobbly. It&#8217;s good spelling but it Wobbles, and the letters get in the wrong places. <span class=u>&#x275E;</span><br>&mdash; Winnie-the-Pooh
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Lan&ccedil;ons Nous</h2>
<p class=f>&Eacute;tant le fils d&#x27;un libraire et d&#x27;une licenci&eacute;e en Anglais, j&#x27;ai toujours &eacute;t&eacute; fascin&eacute; par les langues. Pas les langages de programmation. Enfin si, aussi. Prenez l&#x27;anglais par exemple. L&#x27;anglais est un langage schizophr&egrave;ne qui empreinte des mots de l&#x27;Allemand, du Fran&ccedil;ais, de l&#x27;Espagnol, et du Latin (pour n&#x27;en nommer qu&#x27;un petit nombre). En fait, &#8220;emprunter&#8221; n&#x27;est pas le bon mot; &#8220;voler&#8221; est plus proche de la v&eacute;rit&eacute;. Ou encore &#8220;assimiler&#8221;&nbsp;&mdash;&nbsp;comme les Borgs. Oui, j&#x27;aime bien cette comparaison.
<p class=c><code>We are the Borg. Your linguistic and etymological distinctiveness will be added to our own. Resistance is futile.</code>
<p>Dans ce chapitre, vous allez apprendre &agrave; mettre des noms au pluriel en Anglais. Ah et puis aussi, &agrave; faire des fonctions qui retournent d&#x27;autres  fonctions, &agrave; construire des expressions r&eacute;guli&egrave;res avanc&eacute;es, et ce que sont les g&eacute;n&eacute;rateurs. Mais tout d&#x27;abord, parlons de comment mettre des noms au pluriel. (Si vous n&#x27;avez pas lu <a href=regular-expressions.html>le chapitre sur les expressions r&eacute;guli&egrave;res</a>, c&#x27;est maintenant ou jamais. Ce chapitre part du principe que vous connaissez les bases des expressions r&eacute;guli&egrave;res, et passe rapidement &agrave; des utilisations un peu plus avanc&eacute;es de celles-ci.)
<p>Si vous avez grandi dans un pays Anglophone ou apprit l&#x27;Anglais à l&#x27;&eacute;cole, vous devez probablement avoir déjà entendu parlé des règles principlaes :
<ul>
<li>Si un mot fini en S, X, ou Z, ajoutez ES. <i>Bass</i> devient <i>basses</i>, <i>fax</i> devient <i>faxes</i>, et <i>waltz</i> devient  <i>waltzes</i>.
<li>Si un mot fini avec un H qui s&#x27;entend, ajoutez ES; s&#x27;il finit avec un H silencieux, ajoutez juste un S. Qu&#x27;est ce qu&#x27;un H qui s&#x27;entend ? C&#x27;est un H combin&eacute; &agrave; d&#x27;autres lettres pour former un son que l&#x27;on entend. Ainsi <i>coach</i> devient <i>coaches</i> et <i>rash</i> devient <i>rashes</i>, car on peut entendre les sons CH et SH quand on prononce ces noms. En revanche <i>cheetah</i> devient <i>cheetahs</i>, car le H est silencieux.
<li>Si un mot finit par un Y qui sonne comme aïe, remplacez le Y  par IES; en revanche si le Y est combiné à une voyelle pour former un nouveau son, ajoutez juste un S. Donc <i>vacancy</i> devient <i>vacancies</i>, mais <i>day</i> devient <i>days</i>.
<li>Quand i n&#x27;y a plus d&#x27;autre espoir, ajoutez un S et priez.
</ul>
<p>(Je sais, il y a beaucoup d&#x27;exceptions. <i>Man</i> devient <i>men</i> et <i>woman</i> devient <i>women</i>, mais <i>human</i> devient <i>humans</i>. <i>Mouse</i> devient <i>mice</i> et <i>louse</i> devient <i>lice</i>, mais <i>house</i> devient <i>houses</i>. <i>Knife</i> devient <i>knives</i> et <i>wife</i> devient <i>wives</i>, mais <i>lowlife</i> devient <i>lowlifes</i>. Et ne me lan&ccedil;er pas sur les mots qui sont leur propre pluriel, comme <i>sheep</i>, <i>deer</i>, et <i>haiku</i>.)
<p>Les autres langues sont, bien s&ucirc;r, tr&egrave;s diff&eacute;rents.
<p>Et si on cr&eacute;ait une biblioth&egrave;que Python qui mettrait au pluriel les noms Anglais. On va commencer avec juste ces quatre r&egrave;gles, mais gardez &agrave; l&#x27;esprit qu&#x27;il faudra in&eacute;vitablement rajouter des exceptions plus tard.
<p class=a>&#x2042;

<h2 id=i-know>J&#x27;ai une id&eacute;e, Utilisons des expressions r&eacute;guli&egrave;res !</h2>
<p>Donc nous allons regarder des mots, ce qui veut dire, au moins en Anglais, que nous allons &eacute;tudier des cha&icirc;nes de caract&egrave;res. Et nous avons des r&egrave;gles qui demandent de chercher des combinaisons pr&eacute;cises de ces caract&egrave;res, et de leur appliquer quelques op&eacute;rations. &Ccedil;a, c&#x27;est un boulot pour des expressions r&eacute;guli&egrave;res !
<p class=d>[<a href=examples/plural1.py>t&eacute;l&eacute;chargez <code>plural1.py</code></a>]
<pre class=pp><code>import re

def plural(noun):          
<a>    if re.search('[sxz]$', noun):             <span class=u>&#x2460;</span></a>
<a>        return re.sub('$', 'es', noun)        <span class=u>&#x2461;</span></a>
    elif re.search('[^aeioudgkprt]h$', noun):
        return re.sub('$', 'es', noun)       
    elif re.search('[^aeiou]y$', noun):      
        return re.sub('y$', 'ies', noun)     
    else:
        return noun + 's'</code></pre>
<ol>
<li>Ceci est une expression r&eacute;guli&egrave;re, mais elle utilise une syntaxe que vous n&#x27;avez pas vu dans le chapitre <a href=regular-expressions.html><i>Expression r&eacute;guli&egrave;res</i></a>. Les crochets permettent de &#8220;rep&eacute;rer un et un seul de ces caract&egrave;res.&#8221; Ainsi la cha&icirc;ne <code>[sxz]</code> permet de rep&eacute;rer &#8220;<code>s</code>, ou <code>x</code>, ou encore <code>z</code>&#8221;, mais seulement un de ces caract&egrave;res. Le symbole <code>$</code> doit maintenant vous &ecirc;tre familier; il symbolise la fin de la string. En combinant ces symboles, on obtient une expression r&eacute;guli&egrave;re qui test si la variable <var>noun</var> finit par un <code>s</code>, un <code>x</code>, ou un <code>z</code>.
<li>La fonction <code>re.sub()</code> en elle-m&ecirc;me permet de remplacer tout ce qui est rep&eacute;r&eacute; par l&#x27;expression r&eacute;guli&egrave;re en entr&eacute;e.
</ol>

<p>Voyons comment ces substitutions fonctionnent sur des cas concrets.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search('[abc]', 'Mark')</kbd>    <span class=u>&#x2460;</span></a>
&lt;_sre.SRE_Match object at 0x001C1FA8>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('[abc]', 'o', 'Mark')</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'Mork'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('[abc]', 'o', 'rock')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>'rook'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('[abc]', 'o', 'caps')</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'oops'</samp></pre>
<ol>
<li>Est ce que la string <code>Mark</code> contient un <code>a</code>, un <code>b</code>, ou un <code>c</code>? Oui, elle contient un <code>a</code>.
<li>OK, donc maintenant trouve un caract&egrave;re <code>a</code>, <code>b</code>, ou <code>c</code>, et replace le par un <code>o</code>. <code>Mark</code> devient alors <code>Mork</code>.
<li>La m&ecirc;me fonction transforme <code>rock</code> en <code>rook</code>.
<li>Vous auriez p&ucirc; croire que cette fonction allait transformer <code>caps</code> en <code>oaps</code>, mais en fait non. <code>re.sub</code> remplace <em>toutes</em> les occurences rep&eacute;r&eacute;es, pas seulement la premi&egrave;re. Donc cette expression r&eacute;guli&egrave;re va transformer <code>caps</code> en <code>oops</code>, car &agrave; la fois le <code>c</code> et le <code>a</code> se transforment en <code>o</code>.
</ol>

<p>Maintenant, retournons &agrave; notre fonction <code>plural()</code>&hellip;

<pre class=pp><code>def plural(noun):          
    if re.search('[sxz]$', noun):            
<a>        return re.sub('$', 'es', noun)         <span class=u>&#x2460;</span></a>
<a>    elif re.search('[^aeioudgkprt]h$', noun):  <span class=u>&#x2461;</span></a>
        return re.sub('$', 'es', noun)
<a>    elif re.search('[^aeiou]y$', noun):        <span class=u>&#x2462;</span></a>
        return re.sub('y$', 'ies', noun)     
    else:
        return noun + 's'</code></pre>
<ol>
<li>Ici, nous rempla&ccedil;ons la fin de la string (symbolis&eacute; par le <code>$</code>) avec la string <code>es</code>. Autrement dit, nous ajoutons <code>es</code> &agrave; la fin de la cha&icirc;ne de caract&egrave;res. Vous pouvez accomplir la m&ecirc;me op&eacute;ration avec une simple concat&eacute;nation de string, par exemple <code>noun + &#x27;es&#x27;</code>, mais j&#x27;ai choisit d&#x27;utiliser les expressions r&eacute;guli&egrave;res pour chacun des r&egrave;gles, pour des raisons qui vous appara&icirc;trons plus clair dans la suite de ce chapitre.
<li>Regargez attentivement, il s&#x27;agit d&#x27;une nouvelle formulation. Le symbole <code>^</code> en tant que premier caract&egrave;re &agrave; l&#x27;int&eacute;rieur des crochets a un sens tr&egrave;s diff&eacute;rent : un sens d&#x27;exclusion. En effet <code>[^abc]</code> signifie &#8220;tout caract&egrave;re <em>&agrave; l&#x27;exception</em> de <code>a</code>, <code>b</code>, ou <code>c</code>&#8221;. Donc <code>[^aeioudgkprt]</code> signifie tout caract&egrave;re &agrave; l&#x27;exception de <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>d</code>, <code>g</code>, <code>k</code>, <code>p</code>, <code>r</code>, ou <code>t</code>. Alors pour &ecirc;tre rep&eacute;r&eacute; par l&#x27;expression r&eacute;guli&egrave;re, ce caract&egrave;re devra &ecirc;tre suivi d&#x27;un <code>h</code>, lui-m&ecirc;me &eacute;tant le dernier caract&egrave;re de la string. Tout bien consid&eacute;r&eacute; on recherche alors les mots qui finissent par un H o&ugrave; le H s&#x27;entend.
<li>Le m&ecirc;me motif est utilis&eacute; ici : rep&eacute;rer les mots qui finissent en Y, o&ugrave; le caract&egrave;re juste avant le Y <em>n&#x27;est pas</em> un <code>a</code>, un <code>e</code>, un <code>i</code>, un <code>o</code>, ou un <code>u</code>. On recherche des mots qui finissent par un Y et produisent le son a&iuml;e.
</ol>

<p>Analysons un peu plus en d&eacute;tails les exclusions dans les expressions r&eacute;guli&egrave;res.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search('[^aeiou]y$', 'vacancy')</kbd>  <span class=u>&#x2460;</span></a>
&lt;_sre.SRE_Match object at 0x001C1FA8>
<a><samp class=p>>>> </samp><kbd class=pp>re.search('[^aeiou]y$', 'boy')</kbd>      <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp>
<samp class=p>>>> </samp><kbd class=pp>re.search('[^aeiou]y$', 'day')</kbd>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search('[^aeiou]y$', 'pita')</kbd>     <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Le mot <code>vacancy</code> est bien reconnu par l&#x27;expression r&eacute;guli&egrave;re, car il finit en <code>cy</code>, et que <code>c</code> n&#x27;est pas <code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, ou <code>u</code>.
<li><code>boy</code> n&#x27;est pas reconnu, car il finit en <code>oy</code>, et on a sp&eacute;cifiquement pr&eacute;cis&eacute; que le caract&egrave;re pr&eacute;c&eacute;dant le <code>y</code> ne pouvait pas &ecirc;tre un <code>o</code>. <code>day</code> n&#x27;est pas reconnu non plus, car il finit en <code>ay</code>.
<li><code>pita</code> n&#x27;est pas reconnu, car il ne finit pas en <code>y</code>.
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('y$', 'ies', 'vacancy')</kbd>               <span class=u>&#x2460;</span></a>
<samp class=pp>'vacancies'</samp>
<samp class=p>>>> </samp><kbd class=pp>re.sub('y$', 'ies', 'agency')</kbd>
<samp class=pp>'agencies'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('([^aeiou])y$', r'\1ies', 'vacancy')</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'vacancies'</samp></pre>
<ol>
<li>Cette expression r&eacute;guli&egrave;re transforme <code>vacancy</code> en <code>vacancies</code> et <code>agency</code> en <code>agencies</code>, ce qui est pr&eacute;cis&eacute;ment ce que l&#x27;on voulait. En revanche il est bon de noter que cette fonction transformerait <code>boy</code> en <code>boies</code>, mais cela n&#x27;arrivera jamais dans notre fonction <code>plural()</code> car on effectue tout d&#x27;abord un <code>re.search</code> pour d&eacute;terminer si l&#x27;on doit (ou non) faire un remplacement avec <code>re.sub</code>.
<li>En passant, j&#x27;aimerais signaler qu&#x27;il est possible de combiner ces deux expressions r&eacute;guli&egrave;res (une pour d&eacute;terminer si la r&egrave;gle s&#x27;applique, et l&#x27;autre pour faire effectivement le remplacement) dans une seule expression r&eacute;guli&egrave;re. Voici ce &agrave; quoi une telle combinaison ressemblerait pour notre cas. En grande partie, cette expression r&eacute;guli&egrave;re devrait vous &ecirc;tre famili&egrave;re : on utilise un groupement, notion que l&#x27;on a appris dans <a href=regular-expressions.html#phonenumbers>l&#x27;&eacute;tude de cas : Lire des num&eacute;ros de t&eacute;l&eacute;phones</a>. Le groupement est utilis&eacute; pour se rappeler du caract&egrave;re juste avant la lettre <code>y</code>. Ainsi dans la string de substitution, on peut utiliser un nouveau symbole, <code>\1</code>, ce qui signifie &#8220;Dis, tu te souviens du premier groupe qu&#x27;on a d&eacute;finit pr&eacute;c&eacute;demment ? mets ce que t&#x27;as r&eacute;cup&eacute;r&eacute; ici.&#8221; Ce qui pour notre exemple se traduit par, tu te souviens du <code>c</code> avant le <code>y</code>; eh bien lors de la substitution, tu mets ce <code>c</code> &agrave; la place du <code>c</code>, et tu mets <code>ies</code> &agrave; la place de <code>y</code>. (Si vous utilisez plus d&#x27;un groupement, vous pouvez utiliser les symboles <code>\2</code> et <code>\3</code> etc.)
</ol>
<p>Les substitutions utilisant les expression r&eacute;guli&egrave;res sont particuli&egrave;rement puissantes, et le symbole <code>\1</code> les rends encore plus puissantes. Mais combiner la rechercher et le remplacement en une seule op&eacute;ration rend la lecture du code plus difficile, et ne permet pas de repr&eacute;senter clairement (en terme de code) les r&egrave;gles enonc&eacute;es pr&eacute;c&eacute;dement pour mettre les noms au pluriel. &Agrave; la base on avait &eacute;nonc&eacute; des r&egrave;gles comme &#8220;si le mot finit par un S, un X, ou un Z, alors ajoutez ES&#8221;. Si vous regardez maintenant cette fonction, vous avez deux lignes de code qui disent respectivement &#8220;si le mot finit par un S, un X, ou un Z, alors ajoutez ES&#8221;. Il n'y a pas plus directe comme traduction.

<p class=a>&#x2042;

<h2 id=a-list-of-functions>Une Liste des Fonctions</h2>

<p>Maintenant nous allons ajouter un niveau d'abstraction. Nous avons commencé par définir un certain nombre de règles : Si ceci, alors il faut faire, sinon vérifier si la règle suivante s'applique. Essayons, temporairement, de complexifier une partie du programme pour en simplifier une autre.

<p class=d>[<a href=examples/plural2.py>t&eacute;l&eacute;charger <code>plural2.py</code></a>]
<pre class=pp><code>import re

def match_sxz(noun):
    return re.search('[sxz]$', noun)

def apply_sxz(noun):
    return re.sub('$', 'es', noun)

def match_h(noun):
    return re.search('[^aeioudgkprt]h$', noun)

def apply_h(noun):
    return re.sub('$', 'es', noun)

<a>def match_y(noun):                             <span class=u>&#x2460;</span></a>
    return re.search('[^aeiou]y$', noun)
        
<a>def apply_y(noun):                             <span class=u>&#x2461;</span></a>
    return re.sub('y$', 'ies', noun)

def match_default(noun):
    return True

def apply_default(noun):
    return noun + 's'

<a>rules = ((match_sxz, apply_sxz),               <span class=u>&#x2462;</span></a>
         (match_h, apply_h),
         (match_y, apply_y),
         (match_default, apply_default)
         )

def plural(noun):           
<a>    for matches_rule, apply_rule in rules:       <span class=u>&#x2463;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>
<ol>
<li>Maintenant, chaque règle est disposée dans sa propre fonction <code>match</code> qui renvoit le résultat de l'appel à <code>re.search()</code>.
<li>Chaque règle possède aussi sa fonction <code>apply</code> qui effectue l'appel à <code>re.sub()</code> pour appliquer la règle de plurialisation.
<li>Au lieu d'avoir une seule fonction (<code>plural()</code>) avec plusieurs règles, on possède maintenant une structure de données <code>rules</code> qui est en fait une liste de paires de fonctions.
<li>Comme les règles ont été séparées entre dans une structure de données différente, la fonction <code>plural()</code> résultante est réduite à juste quelques lignes de code. En utilisant juste un boucle <code>for</code>, on peut ainsi extraire et appliquer les règles en une seule opération (une fonction recherche, l'autre applique) sur la structure de données <var>rules</var>. &Agrave; la première itération de la boucle <code>for</code>, la variable <var>matches_rule</var> va devenir <code>match_sxz</code>, et  <var>apply_rule</var> va devenir <code>apply_sxz</code>. &Agrave; la seconde itération (en supposant qu'on arrive aussi loin ), la variable <var>matches_rule</var> va devenir <code>match_h</code>, et <var>apply_rule</var> va devenir <code>apply_h</code>. Cette fonction retourne un résultat de manière certaine, car la dernière règle (<code>match_default</code>) renvoie purement et simplement <code>True</code>, ce qui signifie que la dernière fonction  (<code>apply_default</code>) sera toujours utilisée.
</ol>

<aside>La variable &#8220;rules&#8221; est une séquence de paires de fonctions.</aside>
<p>La raison pour laquelle cette technique fonctionne est que <a href=your-first-python-program.html#everythingisanobject>en Python tout est un Objet</a>, même les fonctions. La structure de données <var>rules</var> contient donc vraiment des functions&nbsp;&mdash;&nbsp;pas des noms de fonctions, mais les objets fonctions. Quand au cour d'une itération de la boucle <code>for</code>, les variables <var>matches_rule</var> et <var>apply_rule</var> se font assigner, ce sont véritablement les fonctions référencées que l'on peut appeler. La première itération de la boucle <code>for</code> est donc équivalente à appeler <code>matches_sxz(noun)</code>, et si cette fonction renvoit <code>True</code>, à appeler <code>apply_sxz(noun)</code>.

<p>Si ce niveau supplémentaire d'abstraction vous semble obscure, essayez de dérouler explicitement la boucle pour voir à chaque étape comment vous auriez écrit l'équivalent. Car en somme la boucle <code>for</code> est équivalente au code suivante :

<pre class='nd pp'><code>
def plural(noun):
    if match_sxz(noun):
        return apply_sxz(noun)
    if match_h(noun):
        return apply_h(noun)
    if match_y(noun):
        return apply_y(noun)
    if match_default(noun):
        return apply_default(noun)</code></pre>

<p>Seulement maintenant la fonction <code>plural()</code> est grandement simplifiée. Elle se base sur une liste de règles, définit ailleurs, et boucle sur cette liste de façon usuelle.

<ol>
<li>Trouves une règle
<li>Elle convient ? Alors appliques la et renvoie le résultat.
<li>Elle ne convient pas ? Alors repart à l'étape n°1.
</ol>

<p>Les règles pourraient être définies n'importe où, et de n'importe quelle façon. La fonction <code>plural()</code> s'en fiche.

<p>Maintenant, est-ce que l'ajout d'un niveau d'abstraction en valait la peine ? En fait, pas encore. Voyons voir ce que nous devons faire pour ajouter une nouvelle règle à la fonction. Dans le premier exemple, il faudrait ajouter un <code>if</code> à la fonction <code>plural()</code>. Dans le second exemple, il faudrait ajouter deux fonctions, <code>match_foo()</code> et <code>apply_foo()</code>, et enfin mettre à jour la liste <var>rules</var> pour spécifier, dans l'ordre des priorités des différentes règles, où se place ces deux nouvelles fonctions.

<p>Mais tout ceci n'est qu'une introduction à la prochaine section. Je vous propose donc d'avancer&hellip;

<p class=a>&#x2042;

<h2 id=a-list-of-patterns>Une liste de patrons</h2>

<p>Définir des fonctions séparées pour chaque phase de recherche et de remplacement n'est pas vraiment nécessaire. Pourquoi ? Tout d'abord parce qu'on ne les appelle jamais directement; on les ajoute à la liste <var>rules</var> et on les appelle depuis celle-ci. De plus, chaque fonction suit un ou deux patrons de conception. Toutes les fonctions de recherche appellent <code>re.search()</code>, et toutes les fonctions de remplacement appellent <code>re.sub()</code>. Essayons de trouver les points communs entre chaque déclarations pour enfin définir de nouvelles règles plus facilement.

<p class=d>[<a href=examples/plural3.py>télécharger <code>plural3.py</code></a>]
<pre class=pp><code>import re

def build_match_and_apply_functions(pattern, search, replace):
<a>    def matches_rule(word):                                     <span class=u>&#x2460;</span></a>
        return re.search(pattern, word)
<a>    def apply_rule(word):                                       <span class=u>&#x2461;</span></a>
        return re.sub(search, replace, word)
<a>    return (matches_rule, apply_rule)                           <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li><code>build_match_and_apply_functions()</code> est une fonction qui va construire de nouvelles fonctions dynamiquement. Elle prend en paramètres d'entrée les variables <var>pattern</var>, <var>search</var> and <var>replace</var>, et définit une fonction <code>matches_rule()</code> qui appelle <code>re.search()</code> avec la paramètre d'entrée <var>pattern</var> de la fonction <code>build_match_and_apply_functions()</code>, et le paramètre d'entrée <var>word</var> de la fonction  <code>matches_rule()</code> que nous sommes en train de construire. Whoa.
<li>La construction de la fonction <code>apply()</code> se base sur le même raisonnement. La fonction apply est une fonction qui ne prend qu'un seul paramètre, et appelle <code>re.sub()</code> avec les paramètres <var>search</var> et <var>replace</var> qui ont été donné à la fonction <code>build_match_and_apply_functions()</code>,  et la variable <var>word</var> qui a été passé à la fonction <code>apply_rule()</code> que nous sommes en train de construire. Cette technique permettant d'utiliser les valeurs de paramètres extérieurs au sein d'une fonction dynamique est appelé <em>closures</em>. En somme on définit des constantes au sein de la fonction apply  que l'on construit : elle ne prend qu'un seul paramètre (<var>word</var>), mais elle agit en fonction de ce paramètre et de deux autres valeurs (<var>search</var> and <var>replace</var>) qui ont été définies lors de la création de la fonction apply.
<li>Finalement, la fonction <code>build_match_and_apply_functions()</code> renvoit un couple de deux valeurs : les deux fonctions que l'on vient de créer. Les constantes utilisées dans ces fonction (<var>pattern</var> au sein de <code>matches_rule()</code>, et <var>search</var> et <var>replace</var> au sein de la fonction  <code>apply_rule()</code>) restent dans ces fonctions, même une fois sortie de la fonction <code>build_match_and_apply_functions()</code>. Ce qui est franchement superbe.
</ol>

<p>Si c'est confus dans votre esprit (c'est tout à fait normal, vu combien c'est étrange), ça devrait devenir plus clair avec cet exemple.

<pre class=pp><code><a>patterns = \                                                        <span class=u>&#x2460;</span></a>
  (
    ('[sxz]$',           '$',  'es'),
    ('[^aeioudgkprt]h$', '$',  'es'),
    ('(qu|[^aeiou])y$',  'y$', 'ies'),
<a>    ('$',                '$',  's')                                 <span class=u>&#x2461;</span></a>
  )
<a>rules = [build_match_and_apply_functions(pattern, search, replace)  <span class=u>&#x2462;</span></a>
         for (pattern, search, replace) in patterns]</code></pre>
<ol>
<li>Nos &#8220;r&egrave;gles&#8221; de pluralisations sont maintenant d&eacute;finies sous la forme d&#x27;un tuple de tuples de <em>strings</em> (et non de fonctions). La premi&egrave;re  string de chaque groupe est l&#x27;expression r&eacute;guli&egrave;re que l&#x27;on utiliserait avec <code>re.search()</code> pour voir si la r&egrave;gle s&#x27;applique. La seconde et troisi&egrave;me string dans chaque groupe sont les expressions de recherche et de remplacement que l&#x27;on utiliserait comme param&egrave;tre &agrave; la fonction <code>re.sub()</code> pour effectivement appliquer la r&egrave;gle permettant de transformer un nom en son pluriel.
<li>Il y a quand m&ecirc;me un petit changement ici, dans la r&egrave;gle par d&eacute;faut. Dans l&#x27;exemple pr&eacute;c&eacute;dent, la fonction <code>match_default()</code> renvoyait simplement  <code>True</code>, pour dire que m&ecirc;me si aucune r&egrave;gle sp&eacute;cifique ne s&#x27;appliquait, il fallait simplement rajouter un <code>s</code> &agrave; la fin de chaque mot. Cet exemple fait quelque chose de fonctionnellement &eacute;quivalent. La derni&egrave;re expression r&eacute;guli&egrave;re v&eacute;rifie si le mot se finit (<code>$</code> repr&eacute;sentant la fin d&#x27;une cha&icirc;ne de caract&egrave;re). Bien s&ucirc;r, chaque string a une fin, m&ecirc;me une cha&icirc;ne de caract&egrave;re vide, donc cette expression r&eacute;guli&egrave;re se v&eacute;rifie tout le temps. Ainsi, elle sert &agrave; la m&ecirc;me chose que la fonction <code>match_default()</code> qui renvoyait tout le temps <code>True</code> : elle s&#x27;assure que m&ecirc;me si aucune r&egrave;gle sp&eacute;cifique ne s&#x27;applique, on ajoute un <code>s</code> &agrave; la fin de chaque mot.
<li>Cette ligne est magique. Elle prend la séquence de strings dans la variable <var>patterns</var> et la transforme en une séquence de fonctions. Comment ? En &#8220;associant&#8221; les strings aux fonctions <code>build_match_and_apply_functions()</code>. C'est à dire, elle prend un triplet de strings et appelle la fonction  <code>build_match_and_apply_functions()</code> avec ces trois strings comme paramètres. La fonction <code>build_match_and_apply_functions()</code> renvoit un tuple de deux fonctions. Ce qui signifie que la variable <var>rules</var> finit par être fonctionnellement équivalente au précédent exemple : une liste de tuples, où chaque tuple est une paire de fonctions. La première fonction étant celle de recherche qui appelle <code>re.search()</code>, et la seconde fonction est celle qui applique la fonction qui appelle <code>re.sub()</code>.
</ol>

<p>Pour achever cette version du script, il ne manque plus que le point d&#x27;entr&eacute;e, la fonction <code>plural()</code>.

<pre class=pp><code>def plural(noun):
<a>    for matches_rule, apply_rule in rules:  <span class=u>&#x2460;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)</code></pre>
<ol>
<li>Comme la liste <var>rules</var> n&#x27;a pas chang&eacute; depuis le dernier exemple, cela ne devrait pas vous surprendre que la fonction <code>plural()</code> n&#x27;ait pas chang&eacute; du tout elle non-plus. Elle est compl&egrave;tement g&eacute;n&eacute;rique; elle prend une liste de fonction r&egrave;gles and les appeller dans l&#x27;ordre. Cela ne compte pas comment les r&egrave;gles sont d&eacute;finies. Dans l&#x27;exemple pr&eacute;c&eacute;dent, elles &eacute;taient d&eacute;finies comme des fonctions nomm&eacute;es s&eacute;par&eacute;es. Maintenant elles sont construites dynamiquement en associant la sortie de la fonction <code>build_match_and_apply_functions()</code> a une liste de strings. Cela n&#x27;a aucune importance, la fonction <code>plural()</code> fonctionne toujours de la m&ecirc;me fa&ccedil;on.
</ol>

<p class=a>&#x2042;

<h2 id=a-file-of-patterns>A File Of Patterns</h2>

<p>You&#8217;ve factored out all the duplicate code and added enough abstractions so that the pluralization rules are defined in a list of strings. The next logical step is to take these strings and put them in a separate file, where they can be maintained separately from the code that uses them.

<p>First, let&#8217;s create a text file that contains the rules you want. No fancy data structures, just whitespace-delimited strings in three columns. Let&#8217;s call it <code>plural4-rules.txt</code>.

<p class=d>[<a href=examples/plural4-rules.txt>download <code>plural4-rules.txt</code></a>]
<pre class='nd pp'><code>[sxz]$               $    es
[^aeioudgkprt]h$     $    es
[^aeiou]y$          y$    ies
$                    $    s</code></pre>

<p>Now let&#8217;s see how you can use this rules file.

<p class=d>[<a href=examples/plural4.py>download <code>plural4.py</code></a>]
<pre class=pp><code>import re

<a>def build_match_and_apply_functions(pattern, search, replace):  <span class=u>&#x2460;</span></a>
    def matches_rule(word):
        return re.search(pattern, word)
    def apply_rule(word):
        return re.sub(search, replace, word)
    return (matches_rule, apply_rule)

rules = []
<a>with open('plural4-rules.txt', encoding='utf-8') as pattern_file:  <span class=u>&#x2461;</span></a>
<a>    for line in pattern_file:                                      <span class=u>&#x2462;</span></a>
<a>        pattern, search, replace = line.split(None, 3)             <span class=u>&#x2463;</span></a>
<a>        rules.append(build_match_and_apply_functions(              <span class=u>&#x2464;</span></a>
                pattern, search, replace))</code></pre>
<ol>
<li>The <code>build_match_and_apply_functions()</code> function has not changed. You&#8217;re still using closures to build two functions dynamically that use variables defined in the outer function.
<li>The global <code>open()</code> function opens a file and returns a file object. In this case, the file we&#8217;re opening contains the pattern strings for pluralizing nouns. The <code>with</code> statement creates what&#8217;s called a <i>context</i>: when the <code>with</code> block ends, Python will automatically close the file, even if an exception is raised inside the <code>with</code> block. You&#8217;ll learn more about <code>with</code> blocks and file objects in the <a href=files.html>Files</a> chapter.
<li>The <code>for line in &lt;fileobject></code> idiom reads data from the open file, one line at a time, and assigns the text to the <var>line</var> variable. You&#8217;ll learn more about reading from files in the <a href=files.html>Files</a> chapter.
<li>Each line in the file really has three values, but they&#8217;re separated by whitespace (tabs or spaces, it makes no difference). To split it out, use the <code>split()</code> string method. The first argument to the <code>split()</code> method is <code>None</code>, which means &#8220;split on any whitespace (tabs or spaces, it makes no difference).&#8221; The second argument is <code>3</code>, which means &#8220;split on whitespace 3 times, then leave the rest of the line alone.&#8221; A line like <code>[sxz]$ $ es</code> will be broken up into the list <code>['[sxz]$', '$', 'es']</code>, which means that <var>pattern</var> will get <code>'[sxz]$'</code>, <var>search</var> will get <code>'$'</code>, and <var>replace</var> will get <code>'es'</code>. That&#8217;s a lot of power in one little line of code.
<li>Finally, you pass <code>pattern</code>, <code>search</code>, and <code>replace</code> to the <code>build_match_and_apply_functions()</code> function, which returns a tuple of functions. You append this tuple to the <var>rules</var> list, and <var>rules</var> ends up storing the list of match and apply functions that the <code>plural()</code> function expects.
</ol>

<p>The improvement here is that you&#8217;ve completely separated the pluralization rules into an external file, so it can be maintained separately from the code that uses it. Code is code, data is data, and life is good.

<p class=a>&#x2042;

<h2 id=generators>Generators</h2>

<p>Wouldn&#8217;t it be grand to have a generic <code>plural()</code> function that parses the rules file? Get rules, check for a match, apply appropriate transformation, go to next rule. That&#8217;s all the <code>plural()</code> function has to do, and that&#8217;s all the <code>plural()</code> function should do.

<p class=d>[<a href=examples/plural5.py>download <code>plural5.py</code></a>]
<pre class='nd pp'><code>def rules(rules_filename):
    with open(rules_filename, encoding='utf-8') as pattern_file:
        for line in pattern_file:
            pattern, search, replace = line.split(None, 3)
            yield build_match_and_apply_functions(pattern, search, replace)

def plural(noun, rules_filename='plural5-rules.txt'):
    for matches_rule, apply_rule in rules(rules_filename):
        if matches_rule(noun):
            return apply_rule(noun)
    raise ValueError('no matching rule for {0}'.format(noun))</code></pre>

<p>How the heck does <em>that</em> work? Let&#8217;s look at an interactive example first.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def make_counter(x):</kbd>
<samp class=p>... </samp><kbd class=pp>    print('entering make_counter')</kbd>
<samp class=p>... </samp><kbd class=pp>    while True:</kbd>
<a><samp class=p>... </samp><kbd class=pp>        yield x</kbd>                    <span class=u>&#x2460;</span></a>
<samp class=p>... </samp><kbd class=pp>        print('incrementing x')</kbd>
<samp class=p>... </samp><kbd class=pp>        x = x + 1</kbd>
<samp class=p>... </samp>
<a><samp class=p>>>> </samp><kbd class=pp>counter = make_counter(2)</kbd>          <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>counter</kbd>                            <span class=u>&#x2462;</span></a>
&lt;generator object at 0x001C9C10>
<a><samp class=p>>>> </samp><kbd class=pp>next(counter)</kbd>                      <span class=u>&#x2463;</span></a>
<samp>entering make_counter
2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(counter)</kbd>                      <span class=u>&#x2464;</span></a>
<samp>incrementing x
3</samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(counter)</kbd>                      <span class=u>&#x2465;</span></a>
<samp>incrementing x
4</samp></pre>
<ol>
<li>The presence of the <code>yield</code> keyword in <code>make_counter</code> means that this is not a normal function. It is a special kind of function which generates values one at a time. You can think of it as a resumable function. Calling it will return a <i>generator</i> that can be used to generate successive values of <var>x</var>.
<li>To create an instance of the <code>make_counter</code> generator, just call it like any other function. Note that this does not actually execute the function code. You can tell this because the first line of the <code>make_counter()</code> function calls <code>print()</code>, but nothing has been printed yet.
<li>The <code>make_counter()</code> function returns a generator object.
<li>The <code>next()</code> function takes a generator object and returns its next value. The first time you call <code>next()</code> with the <var>counter</var> generator, it executes the code in <code>make_counter()</code> up to the first <code>yield</code> statement, then returns the value that was yielded. In this case, that will be <code>2</code>, because you originally created the generator by calling <code>make_counter(2)</code>.
<li>Repeatedly calling <code>next()</code> with the same generator object resumes exactly where it left off and continues until it hits the next <code>yield</code> statement. All variables, local state, <i class=baa>&amp;</i>c. are saved on <code>yield</code> and restored on <code>next()</code>. The next line of code waiting to be executed calls <code>print()</code>, which prints <samp>incrementing x</samp>. After that, the statement <code>x = x + 1</code>. Then it loops through the <code>while</code> loop again, and the first thing it hits is the statement <code>yield x</code>, which saves the state of everything and returns the current value of <var>x</var> (now <code>3</code>).
<li>The second time you call <code>next(counter)</code>, you do all the same things again, but this time <var>x</var> is now <code>4</code>.
</ol>

<p>Since <code>make_counter</code> sets up an infinite loop, you could theoretically do this forever, and it would just keep incrementing <var>x</var> and spitting out values. But let&#8217;s look at more productive uses of generators instead.

<h3 id=a-fibonacci-generator>A Fibonacci Generator</h3>

<aside>&#8220;yield&#8221; pauses a function. &#8220;next()&#8221; resumes where it left off.</aside>

<p class=d>[<a href=examples/fibonacci.py>download <code>fibonacci.py</code></a>]
<pre class=pp><code>def fib(max):
<a>    a, b = 0, 1          <span class=u>&#x2460;</span></a>
    while a &lt; max:
<a>        yield a          <span class=u>&#x2461;</span></a>
<a>        a, b = b, a + b  <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li>The Fibonacci sequence is a sequence of numbers where each number is the sum of the two numbers before it. It starts with 0 and <code>1</code>, goes up slowly at first, then more and more rapidly. To start the sequence, you need two variables: <var>a</var> starts at 0, and <var>b</var> starts at <code>1</code>.
<li><var>a</var> is the current number in the sequence, so yield it.
<li><var>b</var> is the next number in the sequence, so assign that to <var>a</var>, but also calculate the next value (<code>a + b</code>) and assign that to <var>b</var> for later use. Note that this happens in parallel; if <var>a</var> is <code>3</code> and <var>b</var> is <code>5</code>, then <code>a, b = b, a + b</code> will set <var>a</var> to <code>5</code> (the previous value of <var>b</var>) and <var>b</var> to <code>8</code> (the sum of the previous values of <var>a</var> and <var>b</var>).
</ol>

<p>So you have a function that spits out successive Fibonacci numbers. Sure, you could do that with recursion, but this way is easier to read. Also, it works well with <code>for</code> loops.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>from fibonacci import fib</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>for n in fib(1000):</kbd>      <span class=u>&#x2460;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    print(n, end=' ')</kbd>    <span class=u>&#x2461;</span></a>
<samp class=pp>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(fib(1000))</kbd>          <span class=u>&#x2462;</span></a>
<samp class=pp>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]</samp></pre>
<ol>
<li>You can use a generator like <code>fib()</code> in a <code>for</code> loop directly. The <code>for</code> loop will automatically call the <code>next()</code> function to get values from the <code>fib()</code> generator and assign them to the <code>for</code> loop index variable (<var>n</var>).
<li>Each time through the <code>for</code> loop, <var>n</var> gets a new value from the <code>yield</code> statement in <code>fib()</code>, and all you have to do is print it out. Once <code>fib()</code> runs out of numbers (<var>a</var> becomes bigger than <var>max</var>, which in this case is <code>1000</code>), then the <code>for</code> loop exits gracefully.
<li>This is a useful idiom: pass a generator to the <code>list()</code> function, and it will iterate through the entire generator (just like the <code>for</code> loop in the previous example) and return a list of all the values.
</ol>

<h3 id=a-plural-rule-generator>A Plural Rule Generator</h3>

<p>Let&#8217;s go back to <code>plural5.py</code> and see how this version of the <code>plural()</code> function works.

<pre class=pp><code>def rules(rules_filename):
    with open(rules_filename, encoding='utf-8') as pattern_file:
        for line in pattern_file:
<a>            pattern, search, replace = line.split(None, 3)                   <span class=u>&#x2460;</span></a>
<a>            yield build_match_and_apply_functions(pattern, search, replace)  <span class=u>&#x2461;</span></a>

def plural(noun, rules_filename='plural5-rules.txt'):
<a>    for matches_rule, apply_rule in rules(rules_filename):                   <span class=u>&#x2462;</span></a>
        if matches_rule(noun):
            return apply_rule(noun)
    raise ValueError('no matching rule for {0}'.format(noun))</code></pre>
<ol>
<li>No magic here. Remember that the lines of the rules file have three values separated by whitespace, so you use <code>line.split(None, 3)</code> to get the three &#8220;columns&#8221; and assign them to three local variables.
<li><em>And then you yield.</em> What do you yield? Two functions, built dynamically with your old friend, <code>build_match_and_apply_functions()</code>, which is identical to the previous examples. In other words, <code>rules()</code> is a generator that spits out match and apply functions <em>on demand</em>.
<li>Since <code>rules()</code> is a generator, you can use it directly in a <code>for</code> loop. The first time through the <code>for</code> loop, you will call the <code>rules()</code> function, which will open the pattern file, read the first line, dynamically build a match function and an apply function from the patterns on that line, and yield the dynamically built functions. The second time through the <code>for</code> loop, you will pick up exactly where you left off in <code>rules()</code> (which was in the middle of the <code>for line in pattern_file</code> loop). The first thing it will do is read the next line of the file (which is still open), dynamically build another match and apply function based on the patterns on that line in the file, and yield the two functions.
</ol>

<p>What have you gained over stage 4? Startup time. In stage 4, when you imported the <code>plural4</code> module, it read the entire patterns file and built a list of all the possible rules, before you could even think about calling the <code>plural()</code> function. With generators, you can do everything lazily: you read the first rule and create functions and try them, and if that works you don&#8217;t ever read the rest of the file or create any other functions.

<p>What have you lost? Performance! Every time you call the <code>plural()</code> function, the <code>rules()</code> generator starts over from the beginning&nbsp;&mdash;&nbsp;which means re-opening the patterns file and reading from the beginning, one line at a time.

<p>What if you could have the best of both worlds: minimal startup cost (don&#8217;t execute any code on <code>import</code>), <em>and</em> maximum performance (don&#8217;t build the same functions over and over again). Oh, and you still want to keep the rules in a separate file (because code is code and data is data), just as long as you never have to read the same line twice.

<p>To do that, you&#8217;ll need to build your own iterator. But before you do <em>that</em>, you need to learn about Python classes.

<p class=a>&#x2042;

<h2 id=furtherreading>Further Reading</h2>
<ul>
<li><a href=http://www.python.org/dev/peps/pep-0255/>PEP 255: Simple Generators</a>
<li><a href=http://effbot.org/zone/python-with-statement.htm>Understanding Python&#8217;s &#8220;with&#8221; statement</a>
<li><a href=http://ynniv.com/blog/2007/08/closures-in-python.html>Closures in Python</a>
<li><a href=http://en.wikipedia.org/wiki/Fibonacci_number>Fibonacci numbers</a>
<li><a href=http://www2.gsu.edu/~wwwesl/egw/crump.htm>English Irregular Plural Nouns</a>
</ul>

<p class=v><a href=regular-expressions.html rel=prev title='back to &#8220;Regular Expressions&#8221;'><span class=u>&#x261C;</span></a> <a href=iterators.html rel=next title='onward to &#8220;Classes &amp; Iterators&#8221;'><span class=u>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;10 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
